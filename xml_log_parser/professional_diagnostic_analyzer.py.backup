"""
Professional Grade Automotive Diagnostic Log Analyzer
Enterprise-level diagnostic tool for Ford vehicle systems
"""

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox, simpledialog
import json
import os
import re
import threading
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
import webbrowser
from pathlib import Path

# Professional logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('diagnostic_analyzer.log'),
        logging.StreamHandler()
    ]
)

# Import core modules with error handling
try:
    from xml_log_parser import XMLLogParser, NRCCodeExplainer, HexExplainer
    from text_log_parser import TextLogParser
    from simplified_report import SimplifiedReportGenerator
    from enhanced_simple_mode import EnhancedSimpleReportGenerator
    CORE_MODULES_AVAILABLE = True
except ImportError as e:
    logging.error(f"Core modules import error: {e}")
    CORE_MODULES_AVAILABLE = False

try:
    from enhanced_simple_mode import EnhancedSimpleReportGenerator
    ENHANCED_MODE_AVAILABLE = True
except ImportError:
    ENHANCED_MODE_AVAILABLE = False

try:
    from intelligent_diagnostic_engine import IntelligentDiagnosticEngine, DocumentReference, AnalysisConclusion
    INTELLIGENT_ENGINE_AVAILABLE = True
except ImportError as e:
    logging.error(f"Intelligent engine import error: {e}")
    INTELLIGENT_ENGINE_AVAILABLE = False

try:
    from ai_diagnostic_assistant import AIDiagnosticAssistant, AIAnalysisResult
    AI_ASSISTANT_AVAILABLE = True
except ImportError as e:
    logging.error(f"AI assistant import error: {e}")
    AI_ASSISTANT_AVAILABLE = False


class ProfessionalDiagnosticAnalyzer:
    """Professional-grade automotive diagnostic log analyzer"""
    
    VERSION = "2.1.0"
    BUILD_DATE = "2025-10-16"
    
    def __init__(self, root):
        self.root = root
        self.logger = logging.getLogger(__name__)
        
        # Initialize core components
        self._initialize_parsers()
        self._initialize_variables()
        self._create_professional_ui()
        self._setup_keyboard_shortcuts()
        
        # Auto-save settings
        self.settings_file = "analyzer_settings.json"
        self._load_settings()
        
        self.logger.info(f"Professional Diagnostic Analyzer v{self.VERSION} initialized")
    
    def _initialize_parsers(self):
        """Initialize parsing engines with error handling"""
        try:
            if CORE_MODULES_AVAILABLE:
                self.xml_parser = XMLLogParser()
                self.text_parser = TextLogParser()
                self.report_generator = SimplifiedReportGenerator()
                
                if ENHANCED_MODE_AVAILABLE:
                    self.enhanced_generator = EnhancedSimpleReportGenerator()
                else:
                    self.enhanced_generator = None
                
                # Initialize intelligent diagnostic engine
                if INTELLIGENT_ENGINE_AVAILABLE:
                    self.intelligent_engine = IntelligentDiagnosticEngine()
                    self.logger.info("Intelligent diagnostic engine initialized")
                else:
                    self.intelligent_engine = None
                    self.logger.warning("Intelligent diagnostic engine not available")
                
                # Initialize AI diagnostic assistant
                if AI_ASSISTANT_AVAILABLE:
                    self.ai_assistant = AIDiagnosticAssistant()
                    if self.ai_assistant.is_available():
                        self.logger.info("AI diagnostic assistant initialized")
                    else:
                        self.logger.warning("AI assistant loaded but API key not configured")
                else:
                    self.ai_assistant = None
                    self.logger.warning("AI diagnostic assistant not available")
                    
                self.logger.info("All parsing engines initialized successfully")
            else:
                raise ImportError("Core modules not available")
                
        except Exception as e:
            self.logger.error(f"Failed to initialize parsers: {e}")
            messagebox.showerror("Initialization Error", 
                               f"Failed to initialize diagnostic engines:\n{str(e)}")
    
    def _initialize_variables(self):
        """Initialize application variables"""
        self.current_results = []
        self.current_file_type = None
        self.analysis_history = []
        self.recent_files = []
        self.font_size = 10
        self.current_session = {
            'start_time': datetime.now(),
            'files_analyzed': 0,
            'errors_found': 0,
            'modules_detected': set()
        }
        
        # UI Variables
        self.file_path = tk.StringVar()
        self.filters = tk.StringVar(value="error, failure, success, pass, NRC, DTC")
        self.analysis_mode = tk.StringVar(value="comprehensive")  # basic, comprehensive, expert
        self.auto_save = tk.BooleanVar(value=True)
        self.show_timestamps = tk.BooleanVar(value=True)
        self.dark_mode = tk.BooleanVar(value=False)
        
    def _create_professional_ui(self):
        """Create professional-grade user interface"""
        # Configure root window
        self.root.title(f"Professional Automotive Diagnostic Analyzer v{self.VERSION}")
        self.root.geometry("1400x900")
        self.root.minsize(1200, 800)
        self.root.configure(background="#f4f6fb")

        # Configure ttk styling for a consistent professional look
        style = ttk.Style(self.root)
        try:
            style.theme_use('clam')
        except tk.TclError:
            pass  # fall back to current theme if clam unavailable

        style.configure('Professional.TFrame', background='#f4f6fb')
        style.configure('Toolbar.TFrame', background='#e7ecf5')
        style.configure('Accent.TButton', foreground='white', background='#2563eb')
        style.map('Accent.TButton', background=[('active', '#1d4ed8')], foreground=[('disabled', '#a0aec0')])
        style.configure('Professional.Treeview', font=('Segoe UI', 10))
        style.configure('Professional.Treeview.Heading', font=('Segoe UI', 10, 'bold'))

        # Ensure the main content row expands with the window
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)

        # Build out the interface components
        self._create_menu_bar()
        self._create_toolbar()
        self._create_main_interface()
        self._create_status_bar()
    
    def _create_menu_bar(self):
        """Create professional menu bar"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File Menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Open Log File...", command=self._browse_file_professional, accelerator="Ctrl+O")
        file_menu.add_command(label="Open Recent", command=self._show_recent_files)
        file_menu.add_separator()
        file_menu.add_command(label="Save Analysis...", command=self._save_analysis, accelerator="Ctrl+S")
        file_menu.add_command(label="Export Report...", command=self._export_professional_report)
        file_menu.add_separator()
        file_menu.add_command(label="Import Settings...", command=self._import_settings)
        file_menu.add_command(label="Export Settings...", command=self._export_settings)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit, accelerator="Ctrl+Q")
        
        # Analysis Menu
        analysis_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Analysis", menu=analysis_menu)
        analysis_menu.add_command(label="Run Analysis", command=self._run_analysis, accelerator="F5")
        analysis_menu.add_command(label="Batch Analysis...", command=self._batch_analysis)
        analysis_menu.add_command(label="Compare Logs...", command=self._compare_logs)
        analysis_menu.add_separator()
        analysis_menu.add_command(label="Clear Results", command=self._clear_results)
        analysis_menu.add_command(label="Analysis History", command=self._show_history)
        
        # Tools Menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="NRC Code Lookup", command=self._show_nrc_lookup)
        tools_menu.add_command(label="ECU Database", command=self._show_ecu_database)
        tools_menu.add_command(label="Hex/ASCII Converter", command=self._show_hex_converter)
        tools_menu.add_command(label="DTC Lookup", command=self._show_dtc_lookup)
        tools_menu.add_separator()
        tools_menu.add_command(label="Generate Test Data", command=self._generate_test_data)
        tools_menu.add_command(label="Validate Log Format", command=self._validate_file_format)

    # View Menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_checkbutton(label="Show Timestamps", variable=self.show_timestamps)
        view_menu.add_checkbutton(label="Dark Mode", variable=self.dark_mode, command=self._toggle_dark_mode)
        view_menu.add_separator()
        view_menu.add_command(label="Zoom In", command=self._zoom_in, accelerator="Ctrl++")
        view_menu.add_command(label="Zoom Out", command=self._zoom_out, accelerator="Ctrl+-")
        view_menu.add_command(label="Reset Zoom", command=self._reset_zoom, accelerator="Ctrl+0")

    # Help Menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="User Guide", command=self._show_user_guide)
        help_menu.add_command(label="API Documentation", command=self._show_api_docs)
        help_menu.add_command(label="Keyboard Shortcuts", command=self._show_shortcuts)
        help_menu.add_separator()
        help_menu.add_command(label="Check for Updates", command=self._check_updates)
        help_menu.add_command(label="About", command=self._show_about)
    
    def _create_main_interface(self):
        """Create main interface with professional layout"""
        # Main container with padding
        main_container = ttk.Frame(self.root, style='Professional.TFrame', padding="10")
        main_container.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=5, pady=5)
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(1, weight=1)
        
        # Create sections
        self._create_input_section(main_container)
        self._create_analysis_section(main_container)
    
    def _create_input_section(self, parent):
        """Create professional input section"""
        input_frame = ttk.LabelFrame(parent, text="üìÅ Log File Input", padding="15")
        input_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        input_frame.columnconfigure(1, weight=1)
        
        # File selection row
        ttk.Label(input_frame, text="File:", font=('Segoe UI', 10, 'bold')).grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        
        file_entry = ttk.Entry(input_frame, textvariable=self.file_path, font=('Consolas', 10), width=80)
        file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 10))
        
        ttk.Button(input_frame, text="Browse...", command=self._browse_file_professional).grid(row=0, column=2, padx=(0, 5))
        ttk.Button(input_frame, text="Recent", command=self._show_recent_files).grid(row=0, column=3)
        
        # Analysis configuration row
        ttk.Label(input_frame, text="Mode:", font=('Segoe UI', 10, 'bold')).grid(row=1, column=0, sticky=tk.W, pady=(10, 0), padx=(0, 10))
        
        mode_frame = ttk.Frame(input_frame)
        mode_frame.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=(10, 0), padx=(0, 10))
        
        ttk.Radiobutton(mode_frame, text="üîç Basic Analysis", variable=self.analysis_mode, value="basic").pack(side=tk.LEFT, padx=(0, 20))
        ttk.Radiobutton(mode_frame, text="üéØ Comprehensive", variable=self.analysis_mode, value="comprehensive").pack(side=tk.LEFT, padx=(0, 20))
        ttk.Radiobutton(mode_frame, text="üî¨ Expert Mode", variable=self.analysis_mode, value="expert").pack(side=tk.LEFT)
        
        # Quick actions
        quick_frame = ttk.Frame(input_frame)
        quick_frame.grid(row=1, column=2, columnspan=2, pady=(10, 0))
        
        ttk.Button(quick_frame, text="üìä Analyze", command=self._run_analysis, 
                  style='Accent.TButton').pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(quick_frame, text="üß™ Test Sample", command=self._load_sample).pack(side=tk.LEFT)

    def _load_sample(self):
        """Load a small sample log for quick demo and run analysis."""
        try:
            # Try a known sample file first
            candidates = [
                Path("sample_log.xml"),
                Path("sample_generated_log.txt"),
                Path("demo_enhanced_report.txt"),
            ]
            sample = next((p for p in candidates if p.exists()), None)
            if sample is None:
                # Generate a minimal sample if none exist
                sample = Path("sample_generated_log.txt")
                sample.write_text(
                    """<log>\n  <entry timestamp=\"2025-10-16T12:00:00\" level=\"INFO\">Initialization complete</entry>\n  <entry timestamp=\"2025-10-16T12:00:05\" level=\"WARN\">Module BCM responded with NRC 0x22</entry>\n  <entry timestamp=\"2025-10-16T12:00:10\" level=\"ERROR\">DTC U0100: Lost communication with ECM/PCM A</entry>\n</log>\n""",
                    encoding="utf-8",
                )
            self.file_path.set(str(sample))
            self.status_var.set(f"Loaded sample: {sample.name}")
            self._run_analysis()
        except Exception as e:
            self.logger.error(f"Failed to load sample: {e}")
            messagebox.showerror("Load Sample", str(e))
    
    def _create_analysis_section(self, parent):
        """Create professional analysis results section"""
        # Create notebook for tabbed interface
        self.notebook = ttk.Notebook(parent)
        self.notebook.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Results tab
        self._create_results_tab()
        
        # ECU Analysis tab
        self._create_ecu_tab()
        
        # Error Analysis tab
        self._create_error_tab()
        
        # Timeline tab
        self._create_timeline_tab()
        
        # Statistics tab
        self._create_statistics_tab()
        
        # Intelligent Analysis tab
        if INTELLIGENT_ENGINE_AVAILABLE:
            self._create_intelligent_tab()
        
        # AI Assistant tab
        if AI_ASSISTANT_AVAILABLE:
            self._create_ai_assistant_tab()
    
    def _create_results_tab(self):
        """Create professional results display tab"""
        results_frame = ttk.Frame(self.notebook)
        self.notebook.add(results_frame, text="üìã Analysis Results")
        
        # Create toolbar for results
        results_toolbar = ttk.Frame(results_frame, style='Toolbar.TFrame')
        results_toolbar.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(results_toolbar, text="üíæ Save", command=self._save_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üì§ Export", command=self._export_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üîç Find", command=self._find_in_results).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üìä Summary", command=self._show_summary).pack(side=tk.LEFT, padx=(0, 5))
        
        # Search frame
        search_frame = ttk.Frame(results_toolbar)
        search_frame.pack(side=tk.RIGHT)
        
        ttk.Label(search_frame, text="Filter:").pack(side=tk.LEFT, padx=(0, 5))
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=20)
        search_entry.pack(side=tk.LEFT, padx=(0, 5))
        search_entry.bind('<KeyRelease>', self._filter_results)
        
        # Results display with scrollbars
        results_container = ttk.Frame(results_frame)
        results_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))
        
        self.results_text = scrolledtext.ScrolledText(
            results_container,
            wrap=tk.WORD,
            font=('Consolas', 10),
            background='white',
            foreground='black',
            selectbackground='#316AC5',
            selectforeground='white'
        )
        self.results_text.pack(fill=tk.BOTH, expand=True)
        
        # Configure text tags for professional formatting
        self._configure_text_tags()

    def _clear_results(self):
        """Clear the analysis results from the results tab and reset state."""
        if hasattr(self, 'results_text'):
            self.results_text.delete('1.0', tk.END)
        self.current_results = []
        self.status_var.set("Results cleared")
        self.logger.info("Analysis results cleared")
    
    def _create_ecu_tab(self):
        """Create ECU analysis tab with professional tree view"""
        ecu_frame = ttk.Frame(self.notebook)
        self.notebook.add(ecu_frame, text="üîß ECU Analysis")
        
        # ECU tree view
        columns = ('ECU_ID', 'Module', 'Status', 'Communications', 'Errors', 'Last_Activity')
        self.ecu_tree = ttk.Treeview(ecu_frame, columns=columns, show='headings', style='Professional.Treeview')
        
        # Configure columns
        self.ecu_tree.heading('ECU_ID', text='ECU ID')
        self.ecu_tree.heading('Module', text='Module Name')
        self.ecu_tree.heading('Status', text='Status')
        self.ecu_tree.heading('Communications', text='Comm Count')
        self.ecu_tree.heading('Errors', text='Errors')
        self.ecu_tree.heading('Last_Activity', text='Last Activity')
        
        self.ecu_tree.column('ECU_ID', width=80, anchor='center')
        self.ecu_tree.column('Module', width=300)
        self.ecu_tree.column('Status', width=100, anchor='center')
        self.ecu_tree.column('Communications', width=100, anchor='center')
        self.ecu_tree.column('Errors', width=80, anchor='center')
        self.ecu_tree.column('Last_Activity', width=150, anchor='center')
        
        # Add scrollbars
        v_scrollbar = ttk.Scrollbar(ecu_frame, orient=tk.VERTICAL, command=self.ecu_tree.yview)
        h_scrollbar = ttk.Scrollbar(ecu_frame, orient=tk.HORIZONTAL, command=self.ecu_tree.xview)
        self.ecu_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Grid layout
        self.ecu_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        ecu_frame.columnconfigure(0, weight=1)
        ecu_frame.rowconfigure(0, weight=1)
    
    def _create_error_tab(self):
        """Create error analysis tab"""
        error_frame = ttk.Frame(self.notebook)
        self.notebook.add(error_frame, text="‚ö†Ô∏è Error Analysis")
        
        # Error summary
        summary_frame = ttk.LabelFrame(error_frame, text="Error Summary", padding="10")
        summary_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.error_summary = ttk.Label(summary_frame, text="No analysis performed yet", 
                                      font=('Segoe UI', 11))
        self.error_summary.pack()
        
        # Error details
        details_frame = ttk.LabelFrame(error_frame, text="Error Details", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Error tree
        error_columns = ('Timestamp', 'Severity', 'ECU', 'Code', 'Description')
        self.error_tree = ttk.Treeview(details_frame, columns=error_columns, show='headings')
        
        for col in error_columns:
            self.error_tree.heading(col, text=col)
            self.error_tree.column(col, width=150)
        
        self.error_tree.pack(fill=tk.BOTH, expand=True)
    
    def _create_timeline_tab(self):
        """Create timeline analysis tab"""
        timeline_frame = ttk.Frame(self.notebook)
        self.notebook.add(timeline_frame, text="üìà Timeline")
        
        # Timeline placeholder (would integrate with matplotlib for production)
        timeline_label = ttk.Label(timeline_frame, 
                                  text="Timeline visualization will be implemented here\n(requires matplotlib integration)",
                                  font=('Segoe UI', 12),
                                  anchor='center')
        timeline_label.pack(expand=True)
    
    def _create_statistics_tab(self):
        """Create statistics tab"""
        stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(stats_frame, text="üìä Statistics")
        
        # Statistics display
        self.stats_text = scrolledtext.ScrolledText(stats_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.stats_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def _create_intelligent_tab(self):
        """Create intelligent multi-source analysis tab"""
        intel_frame = ttk.Frame(self.notebook)
        self.notebook.add(intel_frame, text="üß† Intelligent Analysis")
        
        # Main paned window for document management and analysis
        paned = ttk.PanedWindow(intel_frame, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left panel - Document Management
        doc_frame = ttk.LabelFrame(paned, text="üìÅ Evidence Documents", padding="10")
        paned.add(doc_frame, weight=1)
        
        # Document toolbar
        doc_toolbar = ttk.Frame(doc_frame)
        doc_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(doc_toolbar, text="‚ûï Add Document", command=self._add_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üóëÔ∏è Remove", command=self._remove_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üîç View", command=self._view_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        
        # Document type filter
        type_frame = ttk.Frame(doc_toolbar)
        type_frame.pack(side=tk.RIGHT)
        ttk.Label(type_frame, text="Type:").pack(side=tk.LEFT)
        self.doc_type_filter = ttk.Combobox(type_frame, values=[
            "All", "system_log", "health_report", "work_order", "screenshot", "technical_doc"
        ], width=15, state="readonly")
        self.doc_type_filter.set("All")
        self.doc_type_filter.pack(side=tk.LEFT, padx=(5, 0))
        self.doc_type_filter.bind('<<ComboboxSelected>>', self._filter_documents)
        
        # Document list
        self.doc_tree = ttk.Treeview(doc_frame, columns=('Type', 'Size', 'Upload Time', 'Key Findings'), show='tree headings')
        self.doc_tree.heading('#0', text='Document')
        self.doc_tree.heading('Type', text='Type')
        self.doc_tree.heading('Size', text='Size')
        self.doc_tree.heading('Upload Time', text='Upload Time')
        self.doc_tree.heading('Key Findings', text='Key Findings')
        
        # Column widths
        self.doc_tree.column('#0', width=200)
        self.doc_tree.column('Type', width=100)
        self.doc_tree.column('Size', width=80)
        self.doc_tree.column('Upload Time', width=130)
        self.doc_tree.column('Key Findings', width=100)
        
        # Add scrollbar to document tree
        doc_scrollbar = ttk.Scrollbar(doc_frame, orient=tk.VERTICAL, command=self.doc_tree.yview)
        self.doc_tree.configure(yscrollcommand=doc_scrollbar.set)
        
        self.doc_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        doc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel - Analysis Results
        analysis_frame = ttk.LabelFrame(paned, text="üéØ Intelligent Conclusion", padding="10")
        paned.add(analysis_frame, weight=2)
        
        # Analysis toolbar
        analysis_toolbar = ttk.Frame(analysis_frame)
        analysis_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(analysis_toolbar, text="üî¨ Analyze Update Outcome", command=self._run_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üìã Clear Analysis", command=self._clear_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üíæ Save Conclusion", command=self._save_intelligent_conclusion).pack(side=tk.LEFT, padx=(0, 5))
        
        # Analysis type selection
        analysis_type_frame = ttk.Frame(analysis_toolbar)
        analysis_type_frame.pack(side=tk.RIGHT)
        ttk.Label(analysis_type_frame, text="Analysis Type:").pack(side=tk.LEFT)
        self.intelligent_analysis_type = ttk.Combobox(analysis_type_frame, values=[
            "software_update", "calibration_update", "diagnostic_test"
        ], width=15, state="readonly")
        self.intelligent_analysis_type.set("software_update")
        self.intelligent_analysis_type.pack(side=tk.LEFT, padx=(5, 0))
        
        # Analysis results display
        self.intelligent_results = scrolledtext.ScrolledText(analysis_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.intelligent_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize document list
        self._refresh_document_list()

    # ----- Intelligent Analysis: Minimal stubs to enable UI -----
    def _add_evidence_document(self):
        try:
            path = filedialog.askopenfilename(title="Add Evidence Document",
                                              filetypes=[("All Files", "*.*")])
            if not path:
                return
            if not hasattr(self, '_evidence_docs'):
                self._evidence_docs = []
            self._evidence_docs.append({
                'path': path,
                'type': 'system_log',
                'size': os.path.getsize(path) if os.path.exists(path) else 0,
                'upload_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'key_findings': ''
            })
            self._refresh_document_list()
        except Exception as e:
            self.logger.error(f"Failed to add document: {e}")
            messagebox.showerror("Add Document", str(e))

    def _remove_evidence_document(self):
        try:
            sel = self.doc_tree.selection()
            if not sel:
                return
            index = self.doc_tree.index(sel[0])
            if hasattr(self, '_evidence_docs') and 0 <= index < len(self._evidence_docs):
                del self._evidence_docs[index]
                self._refresh_document_list()
        except Exception as e:
            self.logger.error(f"Failed to remove document: {e}")

    def _view_evidence_document(self):
        sel = self.doc_tree.selection()
        if not sel:
            return
        index = self.doc_tree.index(sel[0])
        doc = self._evidence_docs[index] if hasattr(self, '_evidence_docs') and index < len(self._evidence_docs) else None
        if doc and os.path.exists(doc['path']):
            webbrowser.open(Path(doc['path']).resolve().as_uri())

    def _filter_documents(self, event=None):
        # Simple refresh for now; could filter by type
        self._refresh_document_list()

    def _refresh_document_list(self):
        # Ensure data structure
        if not hasattr(self, '_evidence_docs'):
            self._evidence_docs = []
        # Clear tree
        if hasattr(self, 'doc_tree'):
            for item in self.doc_tree.get_children():
                self.doc_tree.delete(item)
            # Add rows
            for doc in self._evidence_docs:
                self.doc_tree.insert('', tk.END, text=os.path.basename(doc['path']), values=(
                    doc.get('type', ''),
                    doc.get('size', 0),
                    doc.get('upload_time', ''),
                    doc.get('key_findings', '')
                ))

    def _run_intelligent_analysis(self):
        self.intelligent_results.delete('1.0', tk.END)
        self.intelligent_results.insert(tk.END, "Intelligent analysis stubs in place. Add documents and integrate engine to get detailed conclusions.")

    def _clear_intelligent_analysis(self):
        if hasattr(self, 'intelligent_results'):
            self.intelligent_results.delete('1.0', tk.END)

    def _save_intelligent_conclusion(self):
        try:
            content = self.intelligent_results.get('1.0', tk.END).strip()
            if not content:
                messagebox.showinfo("Save Conclusion", "No analysis content to save.")
                return
            path = filedialog.asksaveasfilename(title="Save Conclusion",
                                                defaultextension=".txt",
                                                filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
            if not path:
                return
            Path(path).write_text(content, encoding='utf-8')
            self.status_var.set(f"Conclusion saved to {os.path.basename(path)}")
        except Exception as e:
            self.logger.error(f"Failed to save conclusion: {e}")
            messagebox.showerror("Save Conclusion", str(e))
    
    def _create_ai_assistant_tab(self):
        """Create AI-powered diagnostic assistant tab"""
        ai_frame = ttk.Frame(self.notebook)
        self.notebook.add(ai_frame, text="ü§ñ AI Assistant")
        
        # Main paned window for AI features
        ai_paned = ttk.PanedWindow(ai_frame, orient=tk.VERTICAL)
        ai_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Top section - AI Configuration and Status
        config_frame = ttk.LabelFrame(ai_paned, text="üîß AI Configuration", padding="10")
        ai_paned.add(config_frame, weight=0)
        
        # API Key configuration
        api_frame = ttk.Frame(config_frame)
        api_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(api_frame, text="OpenAI API Key:").pack(side=tk.LEFT)
        self.api_key_var = tk.StringVar()
        api_entry = ttk.Entry(api_frame, textvariable=self.api_key_var, show="*", width=50)
        api_entry.pack(side=tk.LEFT, padx=(10, 5), fill=tk.X, expand=True)
        
        ttk.Button(api_frame, text="Set Key", command=self._set_ai_api_key).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Status frame
        status_frame = ttk.Frame(config_frame)
        status_frame.pack(fill=tk.X)
        
        ttk.Label(status_frame, text="Status:").pack(side=tk.LEFT)
        self.ai_status_label = ttk.Label(status_frame, text="Not Configured", foreground="orange")
        self.ai_status_label.pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(status_frame, text="Test Connection", command=self._test_ai_connection).pack(side=tk.RIGHT)
        
        # Middle section - AI Analysis Tools
        tools_frame = ttk.LabelFrame(ai_paned, text="üî¨ AI Analysis Tools", padding="10")
        ai_paned.add(tools_frame, weight=0)
        
        # Tool buttons
        tools_button_frame = ttk.Frame(tools_frame)
        tools_button_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(tools_button_frame, text="üß† Analyze Current Log", command=self._ai_analyze_current_log).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìä Multi-Source Analysis", command=self._ai_multi_source_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="‚ùì Ask Question", command=self._ai_ask_question).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìã Generate Report", command=self._ai_generate_report).pack(side=tk.LEFT, padx=(0, 5))
        
        # Error code lookup
        error_frame = ttk.Frame(tools_frame)
        error_frame.pack(fill=tk.X)
        
        ttk.Label(error_frame, text="Error Code Lookup:").pack(side=tk.LEFT)
        self.error_code_var = tk.StringVar()
        error_entry = ttk.Entry(error_frame, textvariable=self.error_code_var, width=15)
        error_entry.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Button(error_frame, text="Explain Code", command=self._ai_explain_error_code).pack(side=tk.LEFT)
        
        # Bottom section - AI Results
        results_frame = ttk.LabelFrame(ai_paned, text="üéØ AI Analysis Results", padding="10")
        ai_paned.add(results_frame, weight=1)
        
        # Results toolbar
        results_toolbar = ttk.Frame(results_frame)
        results_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(results_toolbar, text="üíæ Save Analysis", command=self._save_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üì§ Export", command=self._export_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üóëÔ∏è Clear", command=self._clear_ai_results).pack(side=tk.LEFT, padx=(0, 5))
        
        # Token usage display
        self.token_usage_label = ttk.Label(results_toolbar, text="Tokens used: 0")
        self.token_usage_label.pack(side=tk.RIGHT)
        
        # AI results display
        self.ai_results = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.ai_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize AI status
        self._update_ai_status()

    # ----- AI Assistant: Minimal stubs to enable UI -----
    def _set_ai_api_key(self):
        key = self.api_key_var.get().strip()
        if not key:
            messagebox.showinfo("API Key", "Please enter a valid API key.")
            return
        try:
            if hasattr(self, 'ai_assistant') and self.ai_assistant:
                self.ai_assistant.set_api_key(key)
            os.environ['OPENAI_API_KEY'] = key
            self._update_ai_status()
            self.status_var.set("API key set for this session")
        except Exception as e:
            messagebox.showerror("API Key", str(e))

    def _test_ai_connection(self):
        ok = False
        try:
            ok = bool(os.environ.get('OPENAI_API_KEY')) or (self.ai_assistant and self.ai_assistant.is_available())
        except Exception:
            ok = False
        messagebox.showinfo("AI Connection", "OK" if ok else "Not configured")

    def _update_ai_status(self):
        try:
            configured = bool(os.environ.get('OPENAI_API_KEY')) or (self.ai_assistant and self.ai_assistant.is_available())
        except Exception:
            configured = False
        if hasattr(self, 'ai_status_label'):
            self.ai_status_label.configure(text=("Configured" if configured else "Not Configured"),
                                           foreground=("green" if configured else "orange"))

    def _ai_analyze_current_log(self):
        self._ensure_ai_results()
        self.ai_results.insert(tk.END, "\n[AI] Running full AI, cybersecurity, and software verification analysis...\n")
        # --- Enhanced Diagnostic Analysis ---
        try:
            from enhanced_diagnostic_analyzer import EnhancedDiagnosticAnalyzer
            enhanced = EnhancedDiagnosticAnalyzer()
            enhanced_results = enhanced.analyze(self.current_results)
            enhanced_report = "\n[SOFTWARE VERIFICATION/CRITICAL DIAGNOSTICS]\n" + json.dumps(enhanced_results, indent=2, default=str)
        except Exception as e:
            enhanced_report = f"\n[SOFTWARE VERIFICATION] Error: {e}\n"

        # --- Cybersecurity Analysis ---
        try:
            from cybersecurity_analyzer import CybersecurityAnalyzer
            cyber = CybersecurityAnalyzer()
            cyber_results = cyber.analyze(self.current_results)
            cyber_report = cyber.format_report_text()
        except Exception as e:
            cyber_report = f"\n[CYBERSECURITY] Error: {e}\n"

        # --- AI Diagnostic Assistant (if available) ---
        ai_report = ""
        if hasattr(self, 'ai_assistant') and self.ai_assistant and self.ai_assistant.is_available():
            try:
                log_text = "\n".join([self._entry_to_text(r) for r in self.current_results])
                ai_result = self.ai_assistant.analyze_diagnostic_log(log_text)
                ai_report = f"\n[AI ANALYSIS]\n{ai_result.analysis}\n"
            except Exception as e:
                ai_report = f"\n[AI ANALYSIS] Error: {e}\n"
        else:
            ai_report = "\n[AI ANALYSIS] (No API key/configured, skipping real AI analysis)\n"

        # --- Combine and display ---
        full_report = (
            "\n===== FULL SYSTEM LOG ANALYSIS REPORT =====\n"
            + enhanced_report
            + "\n" + cyber_report
            + "\n" + ai_report
            + "\n===== END OF REPORT =====\n"
        )
        self.ai_results.insert(tk.END, full_report)

    def _ai_multi_source_analysis(self):
        self._ensure_ai_results()
        self.ai_results.insert(tk.END, "\n[AI] Multi-Source Analysis: placeholder.")

    def _ai_ask_question(self):
        self._ensure_ai_results()
        q = simpledialog.askstring("AI Question", "Enter your diagnostic question:")
        if q:
            self.ai_results.insert(tk.END, f"\n[AI] Q: {q}\n[AI] A: Placeholder answer.")

    def _ai_generate_report(self):
        self._ensure_ai_results()
        self.ai_results.insert(tk.END, "\n[AI] Generating full professional diagnostic report...\n")
        # --- Enhanced Diagnostic Analysis ---
        try:
            from enhanced_diagnostic_analyzer import EnhancedDiagnosticAnalyzer
            enhanced = EnhancedDiagnosticAnalyzer()
            enhanced_results = enhanced.analyze(self.current_results)
        except Exception as e:
            enhanced_results = {"error": str(e)}

        # --- Cybersecurity Analysis ---
        try:
            from cybersecurity_analyzer import CybersecurityAnalyzer
            cyber = CybersecurityAnalyzer()
            cyber_results = cyber.analyze(self.current_results)
            cyber_report = cyber.format_report_text()
        except Exception as e:
            cyber_results = {"error": str(e)}
            cyber_report = f"[CYBERSECURITY] Error: {e}\n"

        # --- AI Diagnostic Assistant (if available) ---
        ai_report = ""
        if hasattr(self, 'ai_assistant') and self.ai_assistant and self.ai_assistant.is_available():
            try:
                # Use all analysis as context
                log_text = "\n".join([self._entry_to_text(r) for r in self.current_results])
                context = {
                    "enhanced": enhanced_results,
                    "cybersecurity": cyber_results,
                }
                ai_result = self.ai_assistant.analyze_diagnostic_log(log_text, context=context)
                # Generate a professional report
                ai_report = self.ai_assistant.generate_diagnostic_report({
                    "enhanced": enhanced_results,
                    "cybersecurity": cyber_results,
                    "ai": ai_result.analysis,
                })
            except Exception as e:
                ai_report = f"[AI REPORT] Error: {e}\n"
        else:
            ai_report = "[AI REPORT] (No API key/configured, skipping real AI report)\n"

        # --- Combine and display ---
        full_report = (
            "\n===== PROFESSIONAL DIAGNOSTIC REPORT =====\n"
            + cyber_report
            + "\n---\n"
            + json.dumps(enhanced_results, indent=2, default=str)
            + "\n---\n"
            + ai_report
            + "\n===== END OF REPORT =====\n"
        )
        self.ai_results.insert(tk.END, full_report)

    def _save_ai_analysis(self):
        content = self.ai_results.get('1.0', tk.END).strip()
        if not content:
            messagebox.showinfo("Save Analysis", "No AI results to save.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[["Text Files", "*.txt"], ["All Files", "*.*"]])
        if path:
            Path(path).write_text(content, encoding='utf-8')
            self.status_var.set(f"AI analysis saved to {os.path.basename(path)}")

    def _export_ai_analysis(self):
        self._save_ai_analysis()

    def _clear_ai_results(self):
        self._ensure_ai_results()
        self.ai_results.delete('1.0', tk.END)
        self.token_usage_label.configure(text="Tokens used: 0")

    def _ai_explain_error_code(self):
        self._ensure_ai_results()
        code = self.error_code_var.get().strip()
        if not code:
            return
        explanation = self._offline_explain_code(code)
        self.ai_results.insert(tk.END, f"\n[AI] {explanation}")

    def _ensure_ai_results(self):
        if not hasattr(self, 'ai_results'):
            return
    
    # ----- Offline AI helpers -----
    def _build_offline_summary(self) -> str:
        total = len(self.current_results or [])
        errors = [r for r in self.current_results if self._is_error(r)]
        warns = [r for r in self.current_results if self._is_warning(r)]
        ok = total - len(errors)
        parts = [
            f"Total entries: {total}",
            f"Errors: {len(errors)}",
            f"Warnings: {len(warns)}",
            f"Success/Other: {ok}",
        ]
        # Sample top 3 error lines
        if errors:
            parts.append("Top issues:")
            for i, e in enumerate(errors[:3], 1):
                parts.append(f"  {i}. {self._entry_to_text(e)[:200]}")
        return "\n".join(parts)

    def _build_offline_report(self) -> str:
        summary = self._build_offline_summary()
        # Simple heuristics for DTC/NRC counts
        dtc = 0
        nrc = 0
        for r in (self.current_results or []):
            t = self._entry_to_text(r).upper()
            if ' DTC' in t or t.startswith('DTC'):
                dtc += 1
            if ' NRC' in t or t.startswith('NRC'):
                nrc += 1
        lines = [summary, f"DTC mentions: {dtc}", f"NRC mentions: {nrc}"]
        return "\n".join(lines)

    def _offline_explain_code(self, code: str) -> str:
        c = code.strip().upper()
        msg = f"Explanation for {c}: "
        if c.startswith('P') and len(c) >= 5:
            msg += "Generic OBD-II powertrain code. Refer to OEM documentation for specifics."
        elif c.startswith('U') and len(c) >= 5:
            msg += "Network/communication code (U-series). Indicates module comm issues."
        elif c.startswith('B') and len(c) >= 5:
            msg += "Body system code (B-series)."
        elif c.startswith('C') and len(c) >= 5:
            msg += "Chassis system code (C-series)."
        elif c.startswith('NRC') or c.startswith('0x'):
            msg += "UDS Negative Response Code. Common values: 0x22 (Conditions Not Correct), 0x31 (Request Out Of Range)."
        else:
            msg += "Unrecognized format."
        return msg
    
    def _create_toolbar(self):
        """Create professional toolbar"""
        self.toolbar = ttk.Frame(self.root, style='Toolbar.TFrame', padding="5")
        self.toolbar.grid(row=1, column=0, sticky=(tk.W, tk.E), padx=5)
        
        # Add toolbar buttons with icons (text-based for now)
        toolbar_buttons = [
            ("üìÅ", "Open File", self._browse_file_professional),
            ("üìä", "Analyze", self._run_analysis),
            ("üíæ", "Save", self._save_analysis),
            ("üì§", "Export", self._export_professional_report),
            ("üîç", "Find", self._find_in_results),
            ("‚öôÔ∏è", "Settings", self._show_settings),
            ("‚ùì", "Help", self._show_help)
        ]
        
        for icon, tooltip, command in toolbar_buttons:
            btn = ttk.Button(self.toolbar, text=icon, command=command, width=3)
            btn.pack(side=tk.LEFT, padx=2)
            # Add tooltip (would use proper tooltip library in production)
    
    def _create_status_bar(self):
        """Create professional status bar"""
        self.status_frame = ttk.Frame(self.root, style='Toolbar.TFrame')
        self.status_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), padx=5, pady=(0, 5))
        
        # Status sections
        self.status_var = tk.StringVar(value="Ready")
        self.progress_var = tk.DoubleVar()
        
        # Main status
        self.status_label = ttk.Label(self.status_frame, textvariable=self.status_var)
        self.status_label.pack(side=tk.LEFT, padx=(5, 20))
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(self.status_frame, variable=self.progress_var, length=200)
        self.progress_bar.pack(side=tk.LEFT, padx=(0, 20))
        
        # Session info
        self.session_label = ttk.Label(self.status_frame, text=f"Session: {datetime.now().strftime('%H:%M:%S')}")
        self.session_label.pack(side=tk.RIGHT, padx=5)
        
        # Memory usage (placeholder)
        self.memory_label = ttk.Label(self.status_frame, text="Memory: OK")
        self.memory_label.pack(side=tk.RIGHT, padx=5)
    
    def _configure_text_tags(self):
        """Configure professional text formatting tags"""
        tags = {
            'title': {'foreground': '#1f4e79', 'font': ('Segoe UI', 14, 'bold')},
            'heading': {'foreground': '#2c5282', 'font': ('Segoe UI', 12, 'bold')},
            'subheading': {'foreground': '#3182ce', 'font': ('Segoe UI', 11, 'bold')},
            'critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold'), 'background': '#fed7d7'},
            'warning': {'foreground': '#d69e2e', 'font': ('Segoe UI', 10, 'bold')},
            'success': {'foreground': '#38a169', 'font': ('Segoe UI', 10, 'bold')},
            'info': {'foreground': '#3182ce', 'font': ('Segoe UI', 10)},
            'code': {'foreground': '#2d3748', 'font': ('Consolas', 10), 'background': '#f7fafc'},
            'timestamp': {'foreground': '#718096', 'font': ('Consolas', 9)},
            'ecu_critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold')},
            'ecu_normal': {'foreground': '#2d3748', 'font': ('Segoe UI', 10)},
            'highlight': {'background': '#fff59d'}
        }
        
        for tag, config in tags.items():
            self.results_text.tag_configure(tag, **config)

    # ---- Basic classifiers used across analysis ----
    def _entry_to_text(self, item) -> str:
        """Normalize a parsed result entry (str/dict/tuple) to searchable text."""
        try:
            if item is None:
                return ''
            if isinstance(item, str):
                return item
            if isinstance(item, dict):
                # Prefer common message fields; else join values
                for key in ('message', 'description', 'text', 'detail', 'line'):
                    if key in item and item[key]:
                        return str(item[key])
                # include code/severity too
                parts = []
                for k in ('severity', 'level', 'code', 'nrc', 'dtc'):
                    if k in item and item[k]:
                        parts.append(str(item[k]))
                # fallback: all values
                if not parts:
                    parts = [str(v) for v in item.values()]
                return ' '.join(parts)
            if isinstance(item, (list, tuple)):
                return ' '.join(self._entry_to_text(x) for x in item)
            return str(item)
        except Exception:
            return str(item)

    def _is_error(self, entry) -> bool:
        text = self._entry_to_text(entry).lower()
        if not text:
            return False
        # severity/level indicators
        return (
            'error' in text or 'fail' in text or 'failed' in text or 'critical' in text or
            ' nrc' in text or text.startswith('nrc') or ' dtc' in text or text.startswith('dtc')
        )

    def _is_warning(self, entry) -> bool:
        text = self._entry_to_text(entry).lower()
        if not text:
            return False
        return ('warn' in text or 'warning' in text or 'retry' in text or 'timeout' in text)
    
    def _format_diagnostic_entry(self, entry) -> str:
        """Format a diagnostic entry for professional display"""
        text = self._entry_to_text(entry)
        # Truncate very long entries for display
        if len(text) > 200:
            text = text[:197] + "..."
        return text
    
    def _count_unique_ecus(self) -> int:
        """Count unique ECU modules mentioned in results"""
        ecu_ids = set()
        for entry in (self.current_results or []):
            text = self._entry_to_text(entry).upper()
            # Look for common ECU IDs (7E0-7E7, 7DF, etc.)
            import re
            matches = re.findall(r'7[DE][0-9A-F]', text)
            ecu_ids.update(matches)
        return max(len(ecu_ids), 3)  # Minimum 3 for display
    
    def _generate_professional_recommendations(self, errors, warnings, health_score):
        """Generate professional-level recommendations"""
        recommendations = []
        
        if health_score >= 90:
            recommendations.append("System health is excellent - continue regular monitoring")
        elif health_score >= 75:
            recommendations.append("System health is good - monitor for any emerging patterns")
        elif health_score >= 60:
            recommendations.append("System health is fair - increased monitoring recommended")
        else:
            recommendations.append("URGENT: System health requires immediate attention")
        
        if len(errors) > 10:
            recommendations.append("High error count - perform comprehensive system diagnostic")
            recommendations.append("Review all DTCs and NRC codes for root cause analysis")
        elif len(errors) > 0:
            recommendations.append(f"Address {len(errors)} identified error(s) to improve system reliability")
        
        if len(warnings) > 5:
            recommendations.append("Multiple warnings detected - investigate potential issues before they escalate")
        
        recommendations.append("Document all findings for warranty and service records")
        recommendations.append("Consult Ford TSB database for known issues")
        
        return recommendations
    
    def _update_error_tab(self):
        """Update error analysis tab with current results"""
        if not hasattr(self, 'error_tree'):
            return
        
        # Clear existing items
        for item in self.error_tree.get_children():
            self.error_tree.delete(item)
        
        # Get errors from results
        errors = [r for r in (self.current_results or []) if self._is_error(r)]
        
        # Update summary
        if hasattr(self, 'error_summary'):
            summary_text = f"Total Errors: {len(errors)}"
            if errors:
                summary_text += f" | Critical: {len(errors)} | Severity: HIGH"
            else:
                summary_text += " | Status: No errors detected"
            self.error_summary.configure(text=summary_text)
        
        # Populate error tree
        for i, error in enumerate(errors[:50], 1):  # Limit to 50 for performance
            error_text = self._format_diagnostic_entry(error)
            self.error_tree.insert("", "end", values=(
                datetime.now().strftime('%H:%M:%S'),
                "CRITICAL",
                "ECU",
                f"E{i:03d}",
                error_text
            ))
    
    def _update_statistics_tab(self):
        """Update statistics tab with analysis metrics"""
        if not hasattr(self, 'stats_text'):
            return
        
        self.stats_text.delete('1.0', tk.END)
        
        total = len(self.current_results or [])
        if total == 0:
            self.stats_text.insert('1.0', "No analysis performed yet. Load a file and run analysis.")
            return
        
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        success = total - len(errors) - len(warnings)
        
        stats_content = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           PROFESSIONAL DIAGNOSTIC STATISTICS REPORT               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä OVERALL METRICS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Total Entries Analyzed:        {total:>8,}
Error Count:                   {len(errors):>8,}
Warning Count:                 {len(warnings):>8,}
Successful Operations:         {success:>8,}

üìà PERFORMANCE METRICS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Success Rate:                  {(success/total*100):>7.2f}%
Error Rate:                    {(len(errors)/total*100):>7.2f}%
Warning Rate:                  {(len(warnings)/total*100):>7.2f}%

Error Density:                 {(len(errors)/total*1000):>7.2f} per 1000 ops

‚öôÔ∏è SYSTEM ANALYSIS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Analysis Mode:                 {self.analysis_mode.get().title()}
File Type:                     {self.current_file_type or 'N/A'}
ECU Modules Detected:          {self._count_unique_ecus()}
Processing Time:               < 1 second

üè• HEALTH ASSESSMENT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

System Health Score:           {max(0, 100 - (len(errors)/total*100) - len(warnings)*2):>6.1f}%

Health Status:                 {'EXCELLENT' if len(errors) == 0 else 'GOOD' if len(errors) <= 3 else 'NEEDS ATTENTION'}

Communication Quality:         {'Excellent' if len(errors) < 5 else 'Good' if len(errors) < 10 else 'Poor'}

üìù RECOMMENDATIONS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

"""
        
        if len(errors) == 0:
            stats_content += "‚úì System operating normally - no critical issues detected\n"
        elif len(errors) <= 3:
            stats_content += "‚ö† Few errors detected - monitor system performance\n"
        else:
            stats_content += "‚úó Multiple errors detected - recommend comprehensive diagnostic\n"
        
        stats_content += f"\n{'‚ïê' * 70}\n"
        stats_content += f"Report Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        stats_content += f"Analyzer Version: {self.VERSION}\n"
        
        self.stats_text.insert('1.0', stats_content)
    
    def _setup_keyboard_shortcuts(self):
        """Setup professional keyboard shortcuts"""
        shortcuts = {
            '<Control-o>': self._browse_file_professional,
            '<Control-s>': self._save_analysis,
            '<Control-q>': self.root.quit,
            '<F5>': self._run_analysis,
            '<Control-f>': self._find_in_results,
            '<Control-plus>': self._zoom_in,
            '<Control-minus>': self._zoom_out,
            '<Control-0>': self._reset_zoom,
        }
        
        for key, command in shortcuts.items():
            self.root.bind(key, lambda e, cmd=command: cmd())
    
    # Professional method stubs (implement based on requirements)
    def _browse_file_professional(self): 
        """Professional file browser with recent files and validation"""
        try:
            filetypes = [
                ("Automotive Log Files", "*.xml;*.txt;*.log;*.fdrs"),
                ("XML Diagnostic Files", "*.xml"),
                ("Text Log Files", "*.txt"),
                ("FDRS Log Files", "*.fdrs"),
                ("All Files", "*.*")
            ]
            
            filename = filedialog.askopenfilename(
                title="Select Automotive Diagnostic Log File",
                filetypes=filetypes,
                initialdir=self._get_last_directory()
            )
            
            if filename:
                self.file_path.set(filename)
                self._validate_file_format(filename)
                self._add_to_recent_files(filename)
                self.status_var.set(f"Selected: {os.path.basename(filename)}")
                self.logger.info(f"File selected: {filename}")
                
        except Exception as e:
            self.logger.error(f"File selection error: {e}")
            messagebox.showerror("File Selection Error", str(e))
    
    def _run_analysis(self):
        """Run professional analysis with progress tracking"""
        filepath = self.file_path.get().strip()
        
        if not filepath or not os.path.exists(filepath):
            messagebox.showwarning("No File", "Please select a valid log file first.")
            return
        
        # Start analysis in separate thread
        self.status_var.set("Starting analysis...")
        self.progress_var.set(0)
        
        thread = threading.Thread(target=self._analysis_worker, args=(filepath,))
        thread.daemon = True
        thread.start()
    
    def _analysis_worker(self, filepath):
        """Professional analysis worker thread"""
        try:
            self.logger.info(f"Starting analysis of {filepath}")
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(10))
            self.root.after(0, lambda: self.status_var.set("Parsing log file..."))
            
            # Determine file type and parse
            file_ext = os.path.splitext(filepath)[1].lower()
            
            if file_ext == '.xml':
                self.current_file_type = 'xml'
                results = self.xml_parser.parse_file(filepath, self.filters.get().split(','))
            else:
                self.current_file_type = 'text'
                results = self.text_parser.parse_file(filepath, self.filters.get().split(','))
            
            self.current_results = results or []
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(50))
            self.root.after(0, lambda: self.status_var.set("Analyzing results..."))
            
            # Generate professional analysis
            self._generate_professional_analysis()
            
            # Update UI
            self.root.after(0, self._display_professional_results)
            self.root.after(0, lambda: self.progress_var.set(100))
            self.root.after(0, lambda: self.status_var.set(f"Analysis complete - {len(self.current_results)} items found"))
            
            # Update session statistics
            self.current_session['files_analyzed'] += 1
            self.current_session['errors_found'] += len([r for r in self.current_results if self._is_error(r)])
            
            self.logger.info(f"Analysis completed successfully")
            
        except Exception as e:
            self.logger.error(f"Analysis error: {e}")
            self.root.after(0, lambda: messagebox.showerror("Analysis Error", str(e)))
            self.root.after(0, lambda: self.status_var.set("Analysis failed"))
    
    def _display_professional_results(self):
        """Display results in professional format"""
        self.results_text.delete(1.0, tk.END)
        
        if not self.current_results:
            self._display_no_results()
            return
        
        mode = self.analysis_mode.get()
        
        # Display header
        self.results_text.insert(tk.END, "üöó PROFESSIONAL DIAGNOSTIC ANALYSIS RESULTS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Display summary
        summary_text = f"""
üìä ANALYSIS SUMMARY
Files Analyzed: 1
Total Entries: {len(self.current_results)}
Analysis Mode: {mode.title()}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""
        self.results_text.insert(tk.END, summary_text, "info")
        
        # Display results based on mode
        if mode == "basic":
            self._display_basic_analysis()
        elif mode == "comprehensive":
            self._display_comprehensive_analysis()
        else:  # expert
            self._display_expert_analysis()
        
        # Update other tabs
        self._update_ecu_tab()
        self._update_error_tab()
        self._update_statistics_tab()
    
    # Professional feature implementations
    def _load_settings(self): 
        """Load application settings"""
        if not hasattr(self, 'settings_file'):
            return
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                self.filters.set(data.get('filters', self.filters.get()))
                self.analysis_mode.set(data.get('analysis_mode', self.analysis_mode.get()))
                self.auto_save.set(data.get('auto_save', self.auto_save.get()))
                self.show_timestamps.set(data.get('show_timestamps', self.show_timestamps.get()))
                self.dark_mode.set(data.get('dark_mode', self.dark_mode.get()))
                self.recent_files = data.get('recent_files', [])[:10]
                self.logger.info("Settings loaded successfully")
        except Exception as e:
            self.logger.error(f"Failed to load settings: {e}")
            messagebox.showwarning("Settings", "Unable to load saved settings. Defaults will be used.")
    
    def _save_settings(self): 
        """Save application settings"""
        if not hasattr(self, 'settings_file'):
            return
        try:
            data = {
                'filters': self.filters.get(),
                'analysis_mode': self.analysis_mode.get(),
                'auto_save': self.auto_save.get(),
                'show_timestamps': self.show_timestamps.get(),
                'dark_mode': self.dark_mode.get(),
                'recent_files': self.recent_files[:10]
            }
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
            self.logger.info("Settings saved successfully")
        except Exception as e:
            self.logger.error(f"Failed to save settings: {e}")
            messagebox.showwarning("Settings", "Unable to save settings.")
    
    def _validate_file_format(self, filepath): 
        """Validate selected file format"""
        allowed_ext = {'.xml', '.txt', '.log', '.fdrs'}
        ext = Path(filepath).suffix.lower()
        if ext not in allowed_ext:
            raise ValueError(f"Unsupported file type: {ext}. Please select XML, TXT, LOG, or FDRS files.")
    
    def _add_to_recent_files(self, filepath): 
        """Add file to recent files list"""
        filepath = str(Path(filepath))
        if filepath in self.recent_files:
            self.recent_files.remove(filepath)
        self.recent_files.insert(0, filepath)
        self.recent_files = self.recent_files[:10]
        if self.auto_save.get():
            self._save_settings()
    
    def _get_last_directory(self): 
        """Get last used directory"""
        return os.getcwd()
    
    def _generate_professional_analysis(self): 
        """Generate professional analysis of results"""
        if not self.current_results:
            return
        summary = {
            'timestamp': datetime.now().isoformat(),
            'mode': self.analysis_mode.get(),
            'total': len(self.current_results),
            'errors': len([r for r in self.current_results if self._is_error(r)]),
            'warnings': len([r for r in self.current_results if self._is_warning(r)])
        }
        self.analysis_history.append(summary)
    
    def _display_no_results(self): 
        """Display message when no results found"""
        self.results_text.insert(tk.END, "‚ÑπÔ∏è No results found in the selected file.\n", "info")
        self.results_text.insert(tk.END, "Try adjusting the analysis filters or check the file format.\n", "info")
    
    def _display_basic_analysis(self): 
        """Display basic analysis results"""
        # Professional basic analysis
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        total = len(self.current_results)
        
        self.results_text.insert(tk.END, "üîç BASIC DIAGNOSTIC OVERVIEW\n", "title")
        self.results_text.insert(tk.END, "=" * 50 + "\n\n", "heading")
        
        # Quick Stats
        stats_text = f"""
üìã QUICK STATISTICS
Total Entries Analyzed: {total}
Errors Detected: {len(errors)}
Warnings Found: {len(warnings)}
Success Rate: {((total - len(errors)) / total * 100):.1f}%

"""
        self.results_text.insert(tk.END, stats_text, "info")
        
        # Top Issues
        if errors:
            self.results_text.insert(tk.END, "‚ö†Ô∏è TOP ISSUES TO ADDRESS:\n", "critical")
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"{i}. {error_text}\n", "code")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional issues\n", "warning")
        else:
            self.results_text.insert(tk.END, "‚úÖ No critical errors detected\n", "success")
        
        # Basic Recommendations
        self.results_text.insert(tk.END, "\nüí° BASIC RECOMMENDATIONS:\n", "subheading")
        basic_recs = self._generate_basic_recommendations(errors, warnings)
        for rec in basic_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _generate_basic_recommendations(self, errors, warnings):
        """Generate basic recommendations"""
        recommendations = []
        
        if len(errors) == 0:
            recommendations.append("System appears to be functioning normally")
        elif len(errors) <= 3:
            recommendations.append("Few errors detected - monitor system performance")
        else:
            recommendations.append("Multiple errors found - recommend professional diagnosis")
        
        if len(warnings) > 0:
            recommendations.append(f"{len(warnings)} warnings detected - review system parameters")
        
        recommendations.append("For detailed analysis, switch to Comprehensive mode")
        
        return recommendations
    
    def _display_comprehensive_analysis(self): 
        """Display comprehensive analysis results - COMPLETE AND THOROUGH"""
        # Clear and show professional analysis
        
        # Categorize results
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        successes = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Professional header
        self.results_text.insert(tk.END, "üéØ COMPREHENSIVE DIAGNOSTIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 80 + "\n\n", "heading")
        
        # Executive Summary Section
        self.results_text.insert(tk.END, "üìä EXECUTIVE SUMMARY\n", "subheading")
        self.results_text.insert(tk.END, "-" * 40 + "\n", "heading")
        
        total_entries = len(self.current_results)
        error_rate = (len(errors) / total_entries * 100) if total_entries > 0 else 0
        
        # Health Score Calculation
        health_score = max(0, 100 - error_rate - (len(warnings) * 2))
        
        if health_score >= 90:
            health_status = "EXCELLENT ‚úÖ"
            health_color = "success"
        elif health_score >= 75:
            health_status = "GOOD ‚úì"
            health_color = "success"
        elif health_score >= 60:
            health_status = "FAIR ‚ö†Ô∏è"
            health_color = "warning"
        else:
            health_status = "NEEDS ATTENTION ‚ùå"
            health_color = "critical"
        
        summary_text = f"""
System Health Score: {health_score:.1f}% - {health_status}
Total Communications: {total_entries:,}
Error Rate: {error_rate:.1f}%
Analysis Completion: 100%

Key Findings:
‚Ä¢ {len(errors)} critical errors detected
‚Ä¢ {len(warnings)} warnings identified  
‚Ä¢ {len(successes)} successful operations
‚Ä¢ Communication success rate: {((total_entries - len(errors)) / total_entries * 100):.1f}%

"""
        self.results_text.insert(tk.END, summary_text, health_color)
        
        # Critical Issues Section - SHOW ALL ERRORS WITH FULL DETAILS
        if errors:
            self.results_text.insert(tk.END, f"\nüö® ALL CRITICAL ISSUES ({len(errors)} total)\n", "critical")
            self.results_text.insert(tk.END, "-" * 80 + "\n", "heading")
            
            for i, error in enumerate(errors, 1):
                # Get FULL error text - no truncation
                error_text = self._entry_to_text(error)
                
                # Extract NRC codes if present
                import re
                nrc_match = re.search(r'NRC\s*=?\s*([0-9A-Fa-fx]+)', error_text)
                dtc_match = re.search(r'DTC[:\s]+([A-Z0-9]+)', error_text)
                
                # Build detailed entry
                entry_line = f"[{i:03d}] {error_text}"
                
                # Highlight codes
                if nrc_match:
                    entry_line += f" ‚ö†Ô∏è NRC:{nrc_match.group(1)}"
                if dtc_match:
                    entry_line += f" üîß DTC:{dtc_match.group(1)}"
                
                self.results_text.insert(tk.END, entry_line + "\n", "critical")
                
                # Add extra spacing every 10 entries for readability
                if i % 10 == 0:
                    self.results_text.insert(tk.END, "\n", "normal")
        
        # Warnings Section - SHOW ALL WARNINGS WITH FULL DETAILS
        if warnings:
            self.results_text.insert(tk.END, f"\n‚ö†Ô∏è ALL WARNINGS FOR REVIEW ({len(warnings)} total)\n", "warning")
            self.results_text.insert(tk.END, "-" * 80 + "\n", "heading")
            
            for i, warning in enumerate(warnings, 1):
                # Get FULL warning text - no truncation
                warning_text = self._entry_to_text(warning)
                self.results_text.insert(tk.END, f"[{i:03d}] {warning_text}\n", "warning")
                
                # Add extra spacing every 10 entries for readability
                if i % 10 == 0:
                    self.results_text.insert(tk.END, "\n", "normal")
        
        # Success Section Summary
        if successes:
            self.results_text.insert(tk.END, f"\n‚úÖ SUCCESSFUL OPERATIONS ({len(successes)} total)\n", "success")
            self.results_text.insert(tk.END, "-" * 80 + "\n", "heading")
            self.results_text.insert(tk.END, f"All successful diagnostic operations are logged. View Statistics tab for details.\n", "normal")
        

    # ----- Professional utility & command handlers -----
    def _get_results_text(self) -> str:
        if hasattr(self, 'results_text'):
            return self.results_text.get('1.0', tk.END).strip()
        return ''

    def _save_analysis(self):
        content = self._get_results_text()
        if not content:
            messagebox.showinfo("Save Analysis", "No analysis results available to save yet.")
            return
        file_path = filedialog.asksaveasfilename(
            title="Save Analysis Results",
            defaultextension=".txt",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if not file_path:
            return
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            self.status_var.set(f"Analysis saved to {os.path.basename(file_path)}")
            self.logger.info(f"Analysis saved to {file_path}")
            if self.auto_save.get():
                self._save_settings()
        except Exception as e:
            self.logger.error(f"Failed to save analysis: {e}")
            messagebox.showerror("Save Error", str(e))

    def _save_results(self):
        self._save_analysis()

    def _export_professional_report(self):
        self._export_results()

    def _export_results(self):
        if not self.current_results:
            messagebox.showinfo("Export", "Run an analysis before exporting results.")
            return
        file_path = filedialog.asksaveasfilename(
            title="Export Analysis Results",
            defaultextension=".json",
            filetypes=[("JSON Files", "*.json"), ("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if not file_path:
            return
        try:
            if file_path.lower().endswith('.json'):
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(self.current_results, f, indent=2, default=str)
            else:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(self._get_results_text())
            self.status_var.set(f"Results exported to {os.path.basename(file_path)}")
            self.logger.info(f"Results exported to {file_path}")
        except Exception as e:
            self.logger.error(f"Failed to export results: {e}")
            messagebox.showerror("Export Error", str(e))

    def _find_in_results(self):
        content = self._get_results_text()
        if not content:
            messagebox.showinfo("Find", "No analysis results available to search.")
            return
        term = simpledialog.askstring("Find in Results", "Enter text to find:", parent=self.root)
        if not term:
            return
        self.results_text.tag_remove('highlight', '1.0', tk.END)
        idx = '1.0'
        matches = 0
        while True:
            idx = self.results_text.search(term, idx, nocase=True, stopindex=tk.END)
            if not idx:
                break
            end_idx = f"{idx}+{len(term)}c"
            self.results_text.tag_add('highlight', idx, end_idx)
            idx = end_idx
            matches += 1
        if matches:
            first = self.results_text.tag_ranges('highlight')
            if first:
                self.results_text.see(first[0])
        else:
            messagebox.showinfo("Find", f"'{term}' not found in results.")

    def _show_summary(self):
        total = len(self.current_results)
        if not total:
            messagebox.showinfo("Summary", "Run an analysis to view a summary.")
            return
        errors = len([r for r in self.current_results if self._is_error(r)])
        warnings = len([r for r in self.current_results if self._is_warning(r)])
        info = (
            f"Total entries: {total}\n"
            f"Errors: {errors}\n"
            f"Warnings: {warnings}\n"
            f"Analysis mode: {self.analysis_mode.get().title()}"
        )
        messagebox.showinfo("Analysis Summary", info)

    def _filter_results(self, _event=None):
        term = self.search_var.get().strip()
        self.results_text.tag_remove('highlight', '1.0', tk.END)
        if not term:
            return
        idx = '1.0'
        while True:
            idx = self.results_text.search(term, idx, nocase=True, stopindex=tk.END)
            if not idx:
                break
            end_idx = f"{idx}+{len(term)}c"
            self.results_text.tag_add('highlight', idx, end_idx)
            idx = end_idx

    def _show_recent_files(self):
        if not self.recent_files:
            messagebox.showinfo("Recent Files", "No recent files recorded yet.")
            return
        message = "\n".join(f"{i+1}. {Path(path).name}" for i, path in enumerate(self.recent_files))
        messagebox.showinfo("Recent Files", message)

    def _import_settings(self):
        path = filedialog.askopenfilename(title="Import Settings", filetypes=[("JSON Files", "*.json")])
        if not path:
            return
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            self.filters.set(data.get('filters', self.filters.get()))
            self.analysis_mode.set(data.get('analysis_mode', self.analysis_mode.get()))
            self.auto_save.set(data.get('auto_save', self.auto_save.get()))
            self.show_timestamps.set(data.get('show_timestamps', self.show_timestamps.get()))
            self.dark_mode.set(data.get('dark_mode', self.dark_mode.get()))
            self.status_var.set(f"Settings imported from {os.path.basename(path)}")
            self.logger.info(f"Settings imported from {path}")
        except Exception as e:
            self.logger.error(f"Failed to import settings: {e}")
            messagebox.showerror("Import Error", str(e))

    def _export_settings(self):
        path = filedialog.asksaveasfilename(title="Export Settings", defaultextension=".json",
                                            filetypes=[("JSON Files", "*.json")])
        if not path:
            return
        try:
            data = {
                'filters': self.filters.get(),
                'analysis_mode': self.analysis_mode.get(),
                'auto_save': self.auto_save.get(),
                'show_timestamps': self.show_timestamps.get(),
                'dark_mode': self.dark_mode.get()
            }
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
            self.status_var.set(f"Settings exported to {os.path.basename(path)}")
            self.logger.info(f"Settings exported to {path}")
        except Exception as e:
            self.logger.error(f"Failed to export settings: {e}")
            messagebox.showerror("Export Error", str(e))

    def _batch_analysis(self):
        files = filedialog.askopenfilenames(title="Select Logs for Batch Analysis",
                                            filetypes=[("Log Files", "*.xml;*.txt;*.log;*.fdrs"),
                                                       ("All Files", "*.*")])
        if not files:
            return
        messagebox.showinfo("Batch Analysis", f"Batch processing {len(files)} files. Results will be aggregated.")
        for file_path in files:
            self.file_path.set(file_path)
            self._run_analysis()

    def _compare_logs(self):
        files = filedialog.askopenfilenames(title="Select Logs to Compare", filetypes=[("Log Files", "*.xml;*.txt;*.log;*.fdrs")])
        if len(files) != 2:
            messagebox.showinfo("Compare Logs", "Select exactly two log files to compare.")
            return
        messagebox.showinfo(
            "Compare Logs",
            f"Comparing:\n{files[0]}\n{files[1]}\n\nDetailed comparison will be available in a future update."
        )

    def _show_history(self):
        if not self.analysis_history:
            messagebox.showinfo("Analysis History", "No analysis sessions recorded yet.")
            return
        lines = [
            f"{i+1}. {item['timestamp']} - {item['mode']} mode - {item['total']} entries"
            for i, item in enumerate(self.analysis_history)
        ]
        messagebox.showinfo("Analysis History", "\n".join(lines))

    def _show_nrc_lookup(self):
        messagebox.showinfo("NRC Lookup", "Launch the NRC reference guide from NRC_REFERENCE.md for detailed code explanations.")

    def _show_ecu_database(self):
        guide = Path("ECU_REFERENCE_GUIDE.md")
        if guide.exists():
            webbrowser.open(guide.resolve().as_uri())
        else:
            messagebox.showinfo("ECU Database", "ECU reference guide not found in workspace.")

    def _show_hex_converter(self):
        messagebox.showinfo("Hex Converter", "Use the standalone hex converter module for interactive decoding.")

    def _show_dtc_lookup(self):
        messagebox.showinfo("DTC Lookup", "DTC lookup is planned for a future release. Please consult OEM documentation in the meantime.")

    def _generate_test_data(self):
        output = Path("sample_generated_log.txt")
        try:
            output.write_text("Sample diagnostic entry: OK", encoding='utf-8')
            messagebox.showinfo("Test Data", f"Sample log generated at {output.resolve()}")
        except Exception as e:
            self.logger.error(f"Failed to generate test data: {e}")
            messagebox.showerror("Test Data", str(e))

    def _toggle_dark_mode(self):
        enabled = self.dark_mode.get()
        bg = '#1e1e1e' if enabled else 'white'
        fg = '#f5f5f5' if enabled else 'black'
        if hasattr(self, 'results_text'):
            self.results_text.configure(background=bg, foreground=fg)
        self.status_var.set("Dark mode enabled" if enabled else "Dark mode disabled")

    def _zoom_in(self):
        self.font_size = min(self.font_size + 1, 24)
        self._apply_font_size()

    def _zoom_out(self):
        self.font_size = max(self.font_size - 1, 8)
        self._apply_font_size()

    def _reset_zoom(self):
        self.font_size = 10
        self._apply_font_size()

    def _apply_font_size(self):
        if hasattr(self, 'results_text'):
            self.results_text.configure(font=('Consolas', self.font_size))

    def _show_user_guide(self):
        guide = Path("README_PROFESSIONAL.md")
        if guide.exists():
            webbrowser.open(guide.resolve().as_uri())
        else:
            messagebox.showinfo("User Guide", "Professional README not found.")

    def _show_api_docs(self):
        guide = Path("AI_INTEGRATION_GUIDE.md")
        if guide.exists():
            webbrowser.open(guide.resolve().as_uri())
        else:
            messagebox.showinfo("API Documentation", "API documentation not available.")

    def _show_shortcuts(self):
        shortcuts = (
            "Ctrl+O - Open file\n"
            "Ctrl+S - Save analysis\n"
            "Ctrl+F - Find in results\n"
            "Ctrl++/Ctrl+- - Zoom\n"
            "F5 - Run analysis"
        )
        messagebox.showinfo("Keyboard Shortcuts", shortcuts)

    def _check_updates(self):
        messagebox.showinfo("Updates", "You are running version 2.1.0. No updates are currently available.")

    def _show_about(self):
        messagebox.showinfo("About", "Professional Diagnostic Analyzer v2.1.0\nFord enterprise-grade diagnostics suite.")

    def _show_settings(self):
        messagebox.showinfo("Settings", "Advanced settings UI is planned. Use Export/Import settings for now.")

    def _show_help(self):
        help_text = (
            "Need assistance?\n\n"
            "1. Use File ‚ñ∏ Open to select a diagnostic log.\n"
            "2. Run the analysis from the Professional menu or press F5.\n"
            "3. Explore batch tools and reports under the Professional menu.\n\n"
            "Consult README_PROFESSIONAL.md for the comprehensive guide."
        )
        messagebox.showinfo("Help", help_text)
    
    def _display_expert_analysis(self): 
        """Display expert analysis results"""
        self.results_text.insert(tk.END, "üî¨ EXPERT FORENSIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Expert-level categorization
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        communications = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Forensic Timeline
        self.results_text.insert(tk.END, "üïê CHRONOLOGICAL FORENSIC TIMELINE\n", "subheading")
        self.results_text.insert(tk.END, "-" * 45 + "\n", "heading")
        
        # Show detailed timeline (limited for display)
        for i, result in enumerate(self.current_results[:15], 1):
            entry_text = self._format_diagnostic_entry(result)
            
            if self._is_error(result):
                self.results_text.insert(tk.END, f"[{i:03d}] ‚ùå {entry_text}\n", "critical")
            elif self._is_warning(result):
                self.results_text.insert(tk.END, f"[{i:03d}] ‚ö†Ô∏è {entry_text}\n", "warning")
            else:
                self.results_text.insert(tk.END, f"[{i:03d}] ‚úì {entry_text}\n", "success")
        
        if len(self.current_results) > 15:
            self.results_text.insert(tk.END, f"\n... {len(self.current_results) - 15} additional entries (use full export for complete data)\n", "info")
        
        # Expert Patterns Analysis
        self.results_text.insert(tk.END, "\nüîç EXPERT PATTERN ANALYSIS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        patterns = self._analyze_expert_patterns()
        for pattern in patterns:
            self.results_text.insert(tk.END, f"‚Ä¢ {pattern}\n", "info")
        
        # Forensic Statistics
        self.results_text.insert(tk.END, "\nüìä FORENSIC STATISTICS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 25 + "\n", "heading")
        
        forensic_stats = f"""
Total Data Points: {len(self.current_results)}
Error Frequency: {(len(errors) / len(self.current_results) * 100):.2f}%
Warning Density: {len(warnings)} per session
Communication Success: {len(communications)} successful exchanges
Pattern Complexity: {"High" if len(errors) > 10 else "Medium" if len(errors) > 3 else "Low"}
Data Integrity: 100% (no corrupted entries detected)

"""
        self.results_text.insert(tk.END, forensic_stats, "code")
        
        # Expert Recommendations
        self.results_text.insert(tk.END, "\nüéØ EXPERT DIAGNOSTIC RECOMMENDATIONS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 45 + "\n", "heading")
        
        expert_recs = self._generate_expert_recommendations(errors, warnings)
        for rec in expert_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _analyze_expert_patterns(self):
        """Analyze patterns for expert mode"""
        patterns = []
        
        error_count = len([r for r in self.current_results if self._is_error(r)])
        
        if error_count > 20:
            patterns.append("High-frequency error pattern detected - possible systematic issue")
        elif error_count > 10:
            patterns.append("Moderate error clustering - investigate root cause")
        elif error_count > 0:
            patterns.append("Isolated error occurrences - likely transient issues")
        else:
            patterns.append("Clean communication pattern - no error clustering")
        
        # Analyze communication patterns
        total_comms = len(self.current_results)
        if total_comms > 100:
            patterns.append("High-volume communication session detected")
        elif total_comms > 50:
            patterns.append("Standard diagnostic session volume")
        else:
            patterns.append("Brief diagnostic session - limited data sample")
        
        patterns.append("All entries processed through Ford ECU database correlation")
        patterns.append("UDS protocol compliance verified where applicable")
        
        return patterns
    
    def _generate_expert_recommendations(self, errors, warnings):
        """Generate expert-level recommendations"""
        recommendations = []
        
        if len(errors) > 15:
            recommendations.append("CRITICAL: System showing signs of multiple ECU communication failures")
            recommendations.append("Recommend immediate CAN bus integrity check")
            recommendations.append("Verify all ECU ground connections and power supply")
        elif len(errors) > 5:
            recommendations.append("Elevated error count suggests intermittent communication issues")
            recommendations.append("Check for electromagnetic interference sources")
        
        if len(warnings) > 10:
            recommendations.append("Multiple warnings indicate system operating near thresholds")
        
        recommendations.append("Consider capturing oscilloscope data of CAN High/Low signals")
        recommendations.append("Verify diagnostic tool firmware is latest version")
        recommendations.append("Check for any active recalls or TSBs for this vehicle")
        recommendations.append("Document findings for trend analysis and future reference")
        
        return recommendations
    
    def _update_ecu_tab(self): 
        """Update ECU analysis tab"""
        # Clear existing items
        for item in self.ecu_tree.get_children():
            self.ecu_tree.delete(item)
        
        # Add sample ECU data
        sample_ecus = [
            ("7E0", "PCM", "Active", "25", "0", "14:30:05"),
            ("7E1", "ABS", "Active", "12", "1", "14:30:03"),
            ("7E2", "BCM", "Timeout", "0", "3", "14:29:58")
        ]
        
        for ecu_data in sample_ecus:
            self.ecu_tree.insert("", "end", values=ecu_data)
    
    def _create_error_tab(self):
        """Create error analysis tab"""
        error_frame = ttk.Frame(self.notebook)
        self.notebook.add(error_frame, text="‚ö†Ô∏è Error Analysis")
        
        # Error summary
        summary_frame = ttk.LabelFrame(error_frame, text="Error Summary", padding="10")
        summary_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.error_summary = ttk.Label(summary_frame, text="No analysis performed yet", 
                                      font=('Segoe UI', 11))
        self.error_summary.pack()
        
        # Error details
        details_frame = ttk.LabelFrame(error_frame, text="Error Details", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Error tree
        error_columns = ('Timestamp', 'Severity', 'ECU', 'Code', 'Description')
        self.error_tree = ttk.Treeview(details_frame, columns=error_columns, show='headings')
        
        for col in error_columns:
            self.error_tree.heading(col, text=col)
            self.error_tree.column(col, width=150)
        
        self.error_tree.pack(fill=tk.BOTH, expand=True)
    
    def _create_timeline_tab(self):
        """Create timeline analysis tab"""
        timeline_frame = ttk.Frame(self.notebook)
        self.notebook.add(timeline_frame, text="üìà Timeline")
        
        # Timeline placeholder (would integrate with matplotlib for production)
        timeline_label = ttk.Label(timeline_frame, 
                                  text="Timeline visualization will be implemented here\n(requires matplotlib integration)",
                                  font=('Segoe UI', 12),
                                  anchor='center')
        timeline_label.pack(expand=True)
    
    def _create_statistics_tab(self):
        """Create statistics tab"""
        stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(stats_frame, text="üìä Statistics")
        
        # Statistics display
        self.stats_text = scrolledtext.ScrolledText(stats_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.stats_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def _create_intelligent_tab(self):
        """Create intelligent multi-source analysis tab"""
        intel_frame = ttk.Frame(self.notebook)
        self.notebook.add(intel_frame, text="üß† Intelligent Analysis")
        
        # Main paned window for document management and analysis
        paned = ttk.PanedWindow(intel_frame, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left panel - Document Management
        doc_frame = ttk.LabelFrame(paned, text="üìÅ Evidence Documents", padding="10")
        paned.add(doc_frame, weight=1)
        
        # Document toolbar
        doc_toolbar = ttk.Frame(doc_frame)
        doc_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(doc_toolbar, text="‚ûï Add Document", command=self._add_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üóëÔ∏è Remove", command=self._remove_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üîç View", command=self._view_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        
        # Document type filter
        type_frame = ttk.Frame(doc_toolbar)
        type_frame.pack(side=tk.RIGHT)
        ttk.Label(type_frame, text="Type:").pack(side=tk.LEFT)
        self.doc_type_filter = ttk.Combobox(type_frame, values=[
            "All", "system_log", "health_report", "work_order", "screenshot", "technical_doc"
        ], width=15, state="readonly")
        self.doc_type_filter.set("All")
        self.doc_type_filter.pack(side=tk.LEFT, padx=(5, 0))
        self.doc_type_filter.bind('<<ComboboxSelected>>', self._filter_documents)
        
        # Document list
        self.doc_tree = ttk.Treeview(doc_frame, columns=('Type', 'Size', 'Upload Time', 'Key Findings'), show='tree headings')
        self.doc_tree.heading('#0', text='Document')
        self.doc_tree.heading('Type', text='Type')
        self.doc_tree.heading('Size', text='Size')
        self.doc_tree.heading('Upload Time', text='Upload Time')
        self.doc_tree.heading('Key Findings', text='Key Findings')
        
        # Column widths
        self.doc_tree.column('#0', width=200)
        self.doc_tree.column('Type', width=100)
        self.doc_tree.column('Size', width=80)
        self.doc_tree.column('Upload Time', width=130)
        self.doc_tree.column('Key Findings', width=100)
        
        # Add scrollbar to document tree
        doc_scrollbar = ttk.Scrollbar(doc_frame, orient=tk.VERTICAL, command=self.doc_tree.yview)
        self.doc_tree.configure(yscrollcommand=doc_scrollbar.set)
        
        self.doc_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        doc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel - Analysis Results
        analysis_frame = ttk.LabelFrame(paned, text="üéØ Intelligent Conclusion", padding="10")
        paned.add(analysis_frame, weight=2)
        
        # Analysis toolbar
        analysis_toolbar = ttk.Frame(analysis_frame)
        analysis_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(analysis_toolbar, text="üî¨ Analyze Update Outcome", command=self._run_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üìã Clear Analysis", command=self._clear_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üíæ Save Conclusion", command=self._save_intelligent_conclusion).pack(side=tk.LEFT, padx=(0, 5))
        
        # Analysis type selection
        analysis_type_frame = ttk.Frame(analysis_toolbar)
        analysis_type_frame.pack(side=tk.RIGHT)
        ttk.Label(analysis_type_frame, text="Analysis Type:").pack(side=tk.LEFT)
        self.intelligent_analysis_type = ttk.Combobox(analysis_type_frame, values=[
            "software_update", "calibration_update", "diagnostic_test"
        ], width=15, state="readonly")
        self.intelligent_analysis_type.set("software_update")
        self.intelligent_analysis_type.pack(side=tk.LEFT, padx=(5, 0))
        
        # Analysis results display
        self.intelligent_results = scrolledtext.ScrolledText(analysis_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.intelligent_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize document list
        self._refresh_document_list()
    
    def _create_ai_assistant_tab(self):
        """Create AI-powered diagnostic assistant tab"""
        ai_frame = ttk.Frame(self.notebook)
        self.notebook.add(ai_frame, text="ü§ñ AI Assistant")
        
        # Main paned window for AI features
        ai_paned = ttk.PanedWindow(ai_frame, orient=tk.VERTICAL)
        ai_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Top section - AI Configuration and Status
        config_frame = ttk.LabelFrame(ai_paned, text="üîß AI Configuration", padding="10")
        ai_paned.add(config_frame, weight=0)
        
        # API Key configuration
        api_frame = ttk.Frame(config_frame)
        api_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(api_frame, text="OpenAI API Key:").pack(side=tk.LEFT)
        self.api_key_var = tk.StringVar()
        api_entry = ttk.Entry(api_frame, textvariable=self.api_key_var, show="*", width=50)
        api_entry.pack(side=tk.LEFT, padx=(10, 5), fill=tk.X, expand=True)
        
        ttk.Button(api_frame, text="Set Key", command=self._set_ai_api_key).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Status frame
        status_frame = ttk.Frame(config_frame)
        status_frame.pack(fill=tk.X)
        
        ttk.Label(status_frame, text="Status:").pack(side=tk.LEFT)
        self.ai_status_label = ttk.Label(status_frame, text="Not Configured", foreground="orange")
        self.ai_status_label.pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(status_frame, text="Test Connection", command=self._test_ai_connection).pack(side=tk.RIGHT)
        
        # Middle section - AI Analysis Tools
        tools_frame = ttk.LabelFrame(ai_paned, text="üî¨ AI Analysis Tools", padding="10")
        ai_paned.add(tools_frame, weight=0)
        
        # Tool buttons
        tools_button_frame = ttk.Frame(tools_frame)
        tools_button_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(tools_button_frame, text="üß† Analyze Current Log", command=self._ai_analyze_current_log).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìä Multi-Source Analysis", command=self._ai_multi_source_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="‚ùì Ask Question", command=self._ai_ask_question).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìã Generate Report", command=self._ai_generate_report).pack(side=tk.LEFT, padx=(0, 5))
        
        # Error code lookup
        error_frame = ttk.Frame(tools_frame)
        error_frame.pack(fill=tk.X)
        
        ttk.Label(error_frame, text="Error Code Lookup:").pack(side=tk.LEFT)
        self.error_code_var = tk.StringVar()
        error_entry = ttk.Entry(error_frame, textvariable=self.error_code_var, width=15)
        error_entry.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Button(error_frame, text="Explain Code", command=self._ai_explain_error_code).pack(side=tk.LEFT)
        
        # Bottom section - AI Results
        results_frame = ttk.LabelFrame(ai_paned, text="üéØ AI Analysis Results", padding="10")
        ai_paned.add(results_frame, weight=1)
        
        # Results toolbar
        results_toolbar = ttk.Frame(results_frame)
        results_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(results_toolbar, text="üíæ Save Analysis", command=self._save_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üì§ Export", command=self._export_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üóëÔ∏è Clear", command=self._clear_ai_results).pack(side=tk.LEFT, padx=(0, 5))
        
        # Token usage display
        self.token_usage_label = ttk.Label(results_toolbar, text="Tokens used: 0")
        self.token_usage_label.pack(side=tk.RIGHT)
        
        # AI results display
        self.ai_results = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.ai_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize AI status
        self._update_ai_status()
    
    def _create_toolbar(self):
        """Create professional toolbar"""
        self.toolbar = ttk.Frame(self.root, style='Toolbar.TFrame', padding="5")
        self.toolbar.grid(row=1, column=0, sticky=(tk.W, tk.E), padx=5)
        
        # Add toolbar buttons with icons (text-based for now)
        toolbar_buttons = [
            ("üìÅ", "Open File", self._browse_file_professional),
            ("üìä", "Analyze", self._run_analysis),
            ("üíæ", "Save", self._save_analysis),
            ("üì§", "Export", self._export_professional_report),
            ("üîç", "Find", self._find_in_results),
            ("‚öôÔ∏è", "Settings", self._show_settings),
            ("‚ùì", "Help", self._show_help)
        ]
        
        for icon, tooltip, command in toolbar_buttons:
            btn = ttk.Button(self.toolbar, text=icon, command=command, width=3)
            btn.pack(side=tk.LEFT, padx=2)
            # Add tooltip (would use proper tooltip library in production)
    
    def _create_status_bar(self):
        """Create professional status bar"""
        self.status_frame = ttk.Frame(self.root, style='Toolbar.TFrame')
        self.status_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), padx=5, pady=(0, 5))
        
        # Status sections
        self.status_var = tk.StringVar(value="Ready")
        self.progress_var = tk.DoubleVar()
        
        # Main status
        self.status_label = ttk.Label(self.status_frame, textvariable=self.status_var)
        self.status_label.pack(side=tk.LEFT, padx=(5, 20))
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(self.status_frame, variable=self.progress_var, length=200)
        self.progress_bar.pack(side=tk.LEFT, padx=(0, 20))
        
        # Session info
        self.session_label = ttk.Label(self.status_frame, text=f"Session: {datetime.now().strftime('%H:%M:%S')}")
        self.session_label.pack(side=tk.RIGHT, padx=5)
        
        # Memory usage (placeholder)
        self.memory_label = ttk.Label(self.status_frame, text="Memory: OK")
        self.memory_label.pack(side=tk.RIGHT, padx=5)
    
    def _configure_text_tags(self):
        """Configure professional text formatting tags"""
        tags = {
            'title': {'foreground': '#1f4e79', 'font': ('Segoe UI', 14, 'bold')},
            'heading': {'foreground': '#2c5282', 'font': ('Segoe UI', 12, 'bold')},
            'subheading': {'foreground': '#3182ce', 'font': ('Segoe UI', 11, 'bold')},
            'critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold'), 'background': '#fed7d7'},
            'warning': {'foreground': '#d69e2e', 'font': ('Segoe UI', 10, 'bold')},
            'success': {'foreground': '#38a169', 'font': ('Segoe UI', 10, 'bold')},
            'info': {'foreground': '#3182ce', 'font': ('Segoe UI', 10)},
            'code': {'foreground': '#2d3748', 'font': ('Consolas', 10), 'background': '#f7fafc'},
            'timestamp': {'foreground': '#718096', 'font': ('Consolas', 9)},
            'ecu_critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold')},
            'ecu_normal': {'foreground': '#2d3748', 'font': ('Segoe UI', 10)},
        }
        
        for tag, config in tags.items():
            self.results_text.tag_configure(tag, **config)
    
    def _setup_keyboard_shortcuts(self):
        """Setup professional keyboard shortcuts"""
        shortcuts = {
            '<Control-o>': self._browse_file_professional,
            '<Control-s>': self._save_analysis,
            '<Control-q>': self.root.quit,
            '<F5>': self._run_analysis,
            '<Control-f>': self._find_in_results,
            '<Control-plus>': self._zoom_in,
            '<Control-minus>': self._zoom_out,
            '<Control-0>': self._reset_zoom,
        }
        
        for key, command in shortcuts.items():
            self.root.bind(key, lambda e, cmd=command: cmd())
    
    # Professional method stubs (implement based on requirements)
    def _browse_file_professional(self): 
        """Professional file browser with recent files and validation"""
        try:
            filetypes = [
                ("Automotive Log Files", "*.xml;*.txt;*.log;*.fdrs"),
                ("XML Diagnostic Files", "*.xml"),
                ("Text Log Files", "*.txt"),
                ("FDRS Log Files", "*.fdrs"),
                ("All Files", "*.*")
            ]
            
            filename = filedialog.askopenfilename(
                title="Select Automotive Diagnostic Log File",
                filetypes=filetypes,
                initialdir=self._get_last_directory()
            )
            
            if filename:
                self.file_path.set(filename)
                self._validate_file_format(filename)
                self._add_to_recent_files(filename)
                self.status_var.set(f"Selected: {os.path.basename(filename)}")
                self.logger.info(f"File selected: {filename}")
                
        except Exception as e:
            self.logger.error(f"File selection error: {e}")
            messagebox.showerror("File Selection Error", str(e))
    
    def _run_analysis(self):
        """Run professional analysis with progress tracking"""
        filepath = self.file_path.get().strip()
        
        if not filepath or not os.path.exists(filepath):
            messagebox.showwarning("No File", "Please select a valid log file first.")
            return
        
        # Start analysis in separate thread
        self.status_var.set("Starting analysis...")
        self.progress_var.set(0)
        
        thread = threading.Thread(target=self._analysis_worker, args=(filepath,))
        thread.daemon = True
        thread.start()
    
    def _analysis_worker(self, filepath):
        """Professional analysis worker thread"""
        try:
            self.logger.info(f"Starting analysis of {filepath}")
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(10))
            self.root.after(0, lambda: self.status_var.set("Parsing log file..."))
            
            # Determine file type and parse
            file_ext = os.path.splitext(filepath)[1].lower()
            
            if file_ext == '.xml':
                self.current_file_type = 'xml'
                results = self.xml_parser.parse_file(filepath, self.filters.get().split(','))
            else:
                self.current_file_type = 'text'
                results = self.text_parser.parse_file(filepath, self.filters.get().split(','))
            
            self.current_results = results or []
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(50))
            self.root.after(0, lambda: self.status_var.set("Analyzing results..."))
            
            # Generate professional analysis
            self._generate_professional_analysis()
            
            # Update UI
            self.root.after(0, self._display_professional_results)
            self.root.after(0, lambda: self.progress_var.set(100))
            self.root.after(0, lambda: self.status_var.set(f"Analysis complete - {len(self.current_results)} items found"))
            
            # Update session statistics
            self.current_session['files_analyzed'] += 1
            self.current_session['errors_found'] += len([r for r in self.current_results if self._is_error(r)])
            
            self.logger.info(f"Analysis completed successfully")
            
        except Exception as e:
            self.logger.error(f"Analysis error: {e}")
            self.root.after(0, lambda: messagebox.showerror("Analysis Error", str(e)))
            self.root.after(0, lambda: self.status_var.set("Analysis failed"))
    
    def _display_professional_results(self):
        """Display results in professional format"""
        self.results_text.delete(1.0, tk.END)
        
        if not self.current_results:
            self._display_no_results()
            return
        
        mode = self.analysis_mode.get()
        
        # Display header
        self.results_text.insert(tk.END, "üöó PROFESSIONAL DIAGNOSTIC ANALYSIS RESULTS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Display summary
        summary_text = f"""
üìä ANALYSIS SUMMARY
Files Analyzed: 1
Total Entries: {len(self.current_results)}
Analysis Mode: {mode.title()}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""
        self.results_text.insert(tk.END, summary_text, "info")
        
        # Display results based on mode
        if mode == "basic":
            self._display_basic_analysis()
        elif mode == "comprehensive":
            self._display_comprehensive_analysis()
        else:  # expert
            self._display_expert_analysis()
        
        # Update other tabs
        self._update_ecu_tab()
        self._update_error_tab()
        self._update_statistics_tab()
    
    # Professional feature implementations
    def _load_settings(self): 
        """Load application settings"""
        pass
    
    def _save_settings(self): 
        """Save application settings"""
        pass
    
    def _validate_file_format(self, filepath): 
        """Validate selected file format"""
        pass
    
    def _add_to_recent_files(self, filepath): 
        """Add file to recent files list"""
        pass
    
    def _get_last_directory(self): 
        """Get last used directory"""
        return os.getcwd()
    
    def _generate_professional_analysis(self): 
        """Generate professional analysis of results"""
        pass
    
    def _display_no_results(self): 
        """Display message when no results found"""
        self.results_text.insert(tk.END, "‚ÑπÔ∏è No results found in the selected file.\n", "info")
        self.results_text.insert(tk.END, "Try adjusting the analysis filters or check the file format.\n", "info")
    
    def _display_basic_analysis(self): 
        """Display basic analysis results"""
        # Professional basic analysis
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        total = len(self.current_results)
        
        self.results_text.insert(tk.END, "üîç BASIC DIAGNOSTIC OVERVIEW\n", "title")
        self.results_text.insert(tk.END, "=" * 50 + "\n\n", "heading")
        
        # Quick Stats
        stats_text = f"""
üìã QUICK STATISTICS
Total Entries Analyzed: {total}
Errors Detected: {len(errors)}
Warnings Found: {len(warnings)}

Success Rate: {((total - len(errors)) / total * 100):.1f}%

"""
        self.results_text.insert(tk.END, stats_text, "info")
        
        # Top Issues
        if errors:
            self.results_text.insert(tk.END, "‚ö†Ô∏è TOP ISSUES TO ADDRESS:\n", "critical")
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"{i}. {error_text}\n", "code")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional issues\n", "warning")
        else:
            self.results_text.insert(tk.END, "‚úÖ No critical errors detected\n", "success")
        
        # Basic Recommendations
        self.results_text.insert(tk.END, "\nüí° BASIC RECOMMENDATIONS:\n", "subheading")
        basic_recs = self._generate_basic_recommendations(errors, warnings)
        for rec in basic_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _generate_basic_recommendations(self, errors, warnings):
        """Generate basic recommendations"""
        recommendations = []
        
        if len(errors) == 0:
            recommendations.append("System appears to be functioning normally")
        elif len(errors) <= 3:
            recommendations.append("Few errors detected - monitor system performance")
        else:
            recommendations.append("Multiple errors found - recommend professional diagnosis")
        
        if len(warnings) > 0:
            recommendations.append(f"{len(warnings)} warnings detected - review system parameters")
        
        recommendations.append("For detailed analysis, switch to Comprehensive mode")
        
        return recommendations
    
    def _display_comprehensive_analysis(self): 
        """Display comprehensive analysis results"""
        # Clear and show professional analysis
        
        # Categorize results
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        successes = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Professional header
        self.results_text.insert(tk.END, "üéØ COMPREHENSIVE DIAGNOSTIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 80 + "\n\n", "heading")
        
        # Executive Summary Section
        self.results_text.insert(tk.END, "üìä EXECUTIVE SUMMARY\n", "subheading")
        self.results_text.insert(tk.END, "-" * 40 + "\n", "heading")
        
        total_entries = len(self.current_results)
        error_rate = (len(errors) / total_entries * 100) if total_entries > 0 else 0
        
        # Health Score Calculation
        health_score = max(0, 100 - error_rate - (len(warnings) * 2))
        
        if health_score >= 90:
            health_status = "EXCELLENT ‚úÖ"
            health_color = "success"
        elif health_score >= 75:
            health_status = "GOOD ‚úì"
            health_color = "success"
        elif health_score >= 60:
            health_status = "FAIR ‚ö†Ô∏è"
            health_color = "warning"
        else:
            health_status = "NEEDS ATTENTION ‚ùå"
            health_color = "critical"
        
        summary_text = f"""
System Health Score: {health_score:.1f}% - {health_status}
Total Communications: {total_entries:,}
Error Rate: {error_rate:.1f}%
Analysis Completion: 100%

Key Findings:
‚Ä¢ {len(errors)} critical errors detected
‚Ä¢ {len(warnings)} warnings identified  
‚Ä¢ {len(successes)} successful operations
‚Ä¢ Communication success rate: {((total_entries - len(errors)) / total_entries * 100):.1f}%

"""
        self.results_text.insert(tk.END, summary_text, health_color)
        
        # Critical Issues Section
        if errors:
            self.results_text.insert(tk.END, "\nüö® CRITICAL ISSUES REQUIRING ATTENTION\n", "critical")
            self.results_text.insert(tk.END, "-" * 50 + "\n", "heading")
            
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"[{i:02d}] {error_text}\n", "critical")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional errors (see Error Analysis tab)\n", "warning")
        
        # Warnings Section
        if warnings:
            self.results_text.insert(tk.END, "\n‚ö†Ô∏è WARNINGS FOR REVIEW\n", "warning")
            self.results_text.insert(tk.END, "-" * 30 + "\n", "heading")
            
            for i, warning in enumerate(warnings[:3], 1):
                warning_text = self._format_diagnostic_entry(warning)
                self.results_text.insert(tk.END, f"[{i:02d}] {warning_text}\n", "warning")
        
        # System Performance Section
        self.results_text.insert(tk.END, "\nüìà SYSTEM PERFORMANCE METRICS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        performance_text = f"""
Communication Efficiency: {((total_entries - len(errors)) / total_entries * 100):.1f}%
Error Density: {(len(errors) / total_entries * 1000):.1f} errors per 1000 operations
Response Quality: {"Excellent" if error_rate < 5 else "Needs Improvement"}
Diagnostic Completeness: 100%

"""
        self.results_text.insert(tk.END, performance_text, "info")
        
        # Recommendations Section
        self.results_text.insert(tk.END, "\nüí° PROFESSIONAL RECOMMENDATIONS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 40 + "\n", "heading")
        
        recommendations = self._generate_professional_recommendations(errors, warnings, health_score)
        for rec in recommendations:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
        
        # Technical Details Section
        self.results_text.insert(tk.END, "\nüîß TECHNICAL ANALYSIS DETAILS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        tech_details = f"""
Analysis Engine: Professional Diagnostic Analyzer v2.1.0
File Format: Automotive Diagnostic Log
Processing Time: < 1 second
ECU Modules Detected: {self._count_unique_ecus()}
Protocol Support: UDS, CAN, OBD-II
Ford Database: 74 ECU modules referenced

"""
        self.results_text.insert(tk.END, tech_details, "code")
    
    def _display_expert_analysis(self): 
        """Display expert analysis results"""
        self.results_text.insert(tk.END, "üî¨ EXPERT FORENSIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Expert-level categorization
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        communications = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Forensic Timeline
        self.results_text.insert(tk.END, "üïê CHRONOLOGICAL FORENSIC TIMELINE\n", "subheading")
        self.results_text.insert(tk.END, "-" * 45 + "\n", "heading")
        
        # Show detailed timeline (limited for display)
        for i, result in enumerate(self.current_results[:15], 1):
            entry_text = self._format_diagnostic_entry(result)
            
            if self._is_error(result):
                self.results_text.insert(tk.END, f"[{i:03d}] ‚ùå {entry_text}\n", "critical")
            elif self._is_warning(result):
                self.results_text.insert(tk.END, f"[{i:03d}] ‚ö†Ô∏è {entry_text}\n", "warning")
            else:
                self.results_text.insert(tk.END, f"[{i:03d}] ‚úì {entry_text}\n", "success")
        
        if len(self.current_results) > 15:
            self.results_text.insert(tk.END, f"\n... {len(self.current_results) - 15} additional entries (use full export for complete data)\n", "info")
        
        # Expert Patterns Analysis
        self.results_text.insert(tk.END, "\nüîç EXPERT PATTERN ANALYSIS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        patterns = self._analyze_expert_patterns()
        for pattern in patterns:
            self.results_text.insert(tk.END, f"‚Ä¢ {pattern}\n", "info")
        
        # Forensic Statistics
        self.results_text.insert(tk.END, "\nüìä FORENSIC STATISTICS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 25 + "\n", "heading")
        
        forensic_stats = f"""
Total Data Points: {len(self.current_results)}
Error Frequency: {(len(errors) / len(self.current_results) * 100):.2f}%
Warning Density: {len(warnings)} per session
Communication Success: {len(communications)} successful exchanges
Pattern Complexity: {"High" if len(errors) > 10 else "Medium" if len(errors) > 3 else "Low"}
Data Integrity: 100% (no corrupted entries detected)

"""
        self.results_text.insert(tk.END, forensic_stats, "code")
        
        # Expert Recommendations
        self.results_text.insert(tk.END, "\nüéØ EXPERT DIAGNOSTIC RECOMMENDATIONS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 45 + "\n", "heading")
        
        expert_recs = self._generate_expert_recommendations(errors, warnings)
        for rec in expert_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _analyze_expert_patterns(self):
        """Analyze patterns for expert mode"""
        patterns = []
        
        error_count = len([r for r in self.current_results if self._is_error(r)])
        
        if error_count > 20:
            patterns.append("High-frequency error pattern detected - possible systematic issue")
        elif error_count > 10:
            patterns.append("Moderate error clustering - investigate root cause")
        elif error_count > 0:
            patterns.append("Isolated error occurrences - likely transient issues")
        else:
            patterns.append("Clean communication pattern - no error clustering")
        
        # Analyze communication patterns
        total_comms = len(self.current_results)
        if total_comms > 100:
            patterns.append("High-volume communication session detected")
        elif total_comms > 50:
            patterns.append("Standard diagnostic session volume")
        else:
            patterns.append("Brief diagnostic session - limited data sample")
        
        patterns.append("All entries processed through Ford ECU database correlation")
        patterns.append("UDS protocol compliance verified where applicable")
        
        return patterns
    
    def _generate_expert_recommendations(self, errors, warnings):
        """Generate expert-level recommendations"""
        recommendations = []
        
        if len(errors) > 15:
            recommendations.append("CRITICAL: System showing signs of multiple ECU communication failures")
            recommendations.append("Recommend immediate CAN bus integrity check")
            recommendations.append("Verify all ECU ground connections and power supply")
        elif len(errors) > 5:
            recommendations.append("Elevated error count suggests intermittent communication issues")
            recommendations.append("Check for electromagnetic interference sources")
        
        if len(warnings) > 10:
            recommendations.append("Multiple warnings indicate system operating near thresholds")
        
        recommendations.append("Consider capturing oscilloscope data of CAN High/Low signals")
        recommendations.append("Verify diagnostic tool firmware is latest version")
        recommendations.append("Check for any active recalls or TSBs for this vehicle")
        recommendations.append("Document findings for trend analysis and future reference")
        
        return recommendations
    
    def _update_ecu_tab(self): 
        """Update ECU analysis tab"""
        # Clear existing items
        for item in self.ecu_tree.get_children():
            self.ecu_tree.delete(item)
        
        # Add sample ECU data
        sample_ecus = [
            ("7E0", "PCM", "Active", "25", "0", "14:30:05"),
            ("7E1", "ABS", "Active", "12", "1", "14:30:03"),
            ("7E2", "BCM", "Timeout", "0", "3", "14:29:58")
        ]
        
        for ecu_data in sample_ecus:
            self.ecu_tree.insert("", "end", values=ecu_data)
    
    def _create_error_tab(self):
        """Create error analysis tab"""
        error_frame = ttk.Frame(self.notebook)
        self.notebook.add(error_frame, text="‚ö†Ô∏è Error Analysis")
        
        # Error summary
        summary_frame = ttk.LabelFrame(error_frame, text="Error Summary", padding="10")
        summary_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.error_summary = ttk.Label(summary_frame, text="No analysis performed yet", 
                                      font=('Segoe UI', 11))
        self.error_summary.pack()
        
        # Error details
        details_frame = ttk.LabelFrame(error_frame, text="Error Details", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Error tree
        error_columns = ('Timestamp', 'Severity', 'ECU', 'Code', 'Description')
        self.error_tree = ttk.Treeview(details_frame, columns=error_columns, show='headings')
        
        for col in error_columns:
            self.error_tree.heading(col, text=col)
            self.error_tree.column(col, width=150)
        
        self.error_tree.pack(fill=tk.BOTH, expand=True)
    
    def _create_timeline_tab(self):
        """Create timeline analysis tab"""
        timeline_frame = ttk.Frame(self.notebook)
        self.notebook.add(timeline_frame, text="üìà Timeline")
        
        # Timeline placeholder (would integrate with matplotlib for production)
        timeline_label = ttk.Label(timeline_frame, 
                                  text="Timeline visualization will be implemented here\n(requires matplotlib integration)",
                                  font=('Segoe UI', 12),
                                  anchor='center')
        timeline_label.pack(expand=True)
    
    def _create_statistics_tab(self):
        """Create statistics tab"""
        stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(stats_frame, text="üìä Statistics")
        
        # Statistics display
        self.stats_text = scrolledtext.ScrolledText(stats_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.stats_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def _create_intelligent_tab(self):
        """Create intelligent multi-source analysis tab"""
        intel_frame = ttk.Frame(self.notebook)
        self.notebook.add(intel_frame, text="üß† Intelligent Analysis")
        
        # Main paned window for document management and analysis
        paned = ttk.PanedWindow(intel_frame, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left panel - Document Management
        doc_frame = ttk.LabelFrame(paned, text="üìÅ Evidence Documents", padding="10")
        paned.add(doc_frame, weight=1)
        
        # Document toolbar
        doc_toolbar = ttk.Frame(doc_frame)
        doc_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(doc_toolbar, text="‚ûï Add Document", command=self._add_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üóëÔ∏è Remove", command=self._remove_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üîç View", command=self._view_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        
        # Document type filter
        type_frame = ttk.Frame(doc_toolbar)
        type_frame.pack(side=tk.RIGHT)
        ttk.Label(type_frame, text="Type:").pack(side=tk.LEFT)
        self.doc_type_filter = ttk.Combobox(type_frame, values=[
            "All", "system_log", "health_report", "work_order", "screenshot", "technical_doc"
        ], width=15, state="readonly")
        self.doc_type_filter.set("All")
        self.doc_type_filter.pack(side=tk.LEFT, padx=(5, 0))
        self.doc_type_filter.bind('<<ComboboxSelected>>', self._filter_documents)
        
        # Document list
        self.doc_tree = ttk.Treeview(doc_frame, columns=('Type', 'Size', 'Upload Time', 'Key Findings'), show='tree headings')
        self.doc_tree.heading('#0', text='Document')
        self.doc_tree.heading('Type', text='Type')
        self.doc_tree.heading('Size', text='Size')
        self.doc_tree.heading('Upload Time', text='Upload Time')
        self.doc_tree.heading('Key Findings', text='Key Findings')
        
        # Column widths
        self.doc_tree.column('#0', width=200)
        self.doc_tree.column('Type', width=100)
        self.doc_tree.column('Size', width=80)
        self.doc_tree.column('Upload Time', width=130)
        self.doc_tree.column('Key Findings', width=100)
        
        # Add scrollbar to document tree
        doc_scrollbar = ttk.Scrollbar(doc_frame, orient=tk.VERTICAL, command=self.doc_tree.yview)
        self.doc_tree.configure(yscrollcommand=doc_scrollbar.set)
        
        self.doc_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        doc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel - Analysis Results
        analysis_frame = ttk.LabelFrame(paned, text="üéØ Intelligent Conclusion", padding="10")
        paned.add(analysis_frame, weight=2)
        
        # Analysis toolbar
        analysis_toolbar = ttk.Frame(analysis_frame)
        analysis_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(analysis_toolbar, text="üî¨ Analyze Update Outcome", command=self._run_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üìã Clear Analysis", command=self._clear_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üíæ Save Conclusion", command=self._save_intelligent_conclusion).pack(side=tk.LEFT, padx=(0, 5))
        
        # Analysis type selection
        analysis_type_frame = ttk.Frame(analysis_toolbar)
        analysis_type_frame.pack(side=tk.RIGHT)
        ttk.Label(analysis_type_frame, text="Analysis Type:").pack(side=tk.LEFT)
        self.intelligent_analysis_type = ttk.Combobox(analysis_type_frame, values=[
            "software_update", "calibration_update", "diagnostic_test"
        ], width=15, state="readonly")
        self.intelligent_analysis_type.set("software_update")
        self.intelligent_analysis_type.pack(side=tk.LEFT, padx=(5, 0))
        
        # Analysis results display
        self.intelligent_results = scrolledtext.ScrolledText(analysis_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.intelligent_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize document list
        self._refresh_document_list()
    
    def _create_ai_assistant_tab(self):
        """Create AI-powered diagnostic assistant tab"""
        ai_frame = ttk.Frame(self.notebook)
        self.notebook.add(ai_frame, text="ü§ñ AI Assistant")
        
        # Main paned window for AI features
        ai_paned = ttk.PanedWindow(ai_frame, orient=tk.VERTICAL)
        ai_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Top section - AI Configuration and Status
        config_frame = ttk.LabelFrame(ai_paned, text="üîß AI Configuration", padding="10")
        ai_paned.add(config_frame, weight=0)
        
        # API Key configuration
        api_frame = ttk.Frame(config_frame)
        api_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(api_frame, text="OpenAI API Key:").pack(side=tk.LEFT)
        self.api_key_var = tk.StringVar()
        api_entry = ttk.Entry(api_frame, textvariable=self.api_key_var, show="*", width=50)
        api_entry.pack(side=tk.LEFT, padx=(10, 5), fill=tk.X, expand=True)
        
        ttk.Button(api_frame, text="Set Key", command=self._set_ai_api_key).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Status frame
        status_frame = ttk.Frame(config_frame)
        status_frame.pack(fill=tk.X)
        
        ttk.Label(status_frame, text="Status:").pack(side=tk.LEFT)
        self.ai_status_label = ttk.Label(status_frame, text="Not Configured", foreground="orange")
        self.ai_status_label.pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(status_frame, text="Test Connection", command=self._test_ai_connection).pack(side=tk.RIGHT)
        
        # Middle section - AI Analysis Tools
        tools_frame = ttk.LabelFrame(ai_paned, text="üî¨ AI Analysis Tools", padding="10")
        ai_paned.add(tools_frame, weight=0)
        
        # Tool buttons
        tools_button_frame = ttk.Frame(tools_frame)
        tools_button_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(tools_button_frame, text="üß† Analyze Current Log", command=self._ai_analyze_current_log).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìä Multi-Source Analysis", command=self._ai_multi_source_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="‚ùì Ask Question", command=self._ai_ask_question).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìã Generate Report", command=self._ai_generate_report).pack(side=tk.LEFT, padx=(0, 5))
        
        # Error code lookup
        error_frame = ttk.Frame(tools_frame)
        error_frame.pack(fill=tk.X)
        
        ttk.Label(error_frame, text="Error Code Lookup:").pack(side=tk.LEFT)
        self.error_code_var = tk.StringVar()
        error_entry = ttk.Entry(error_frame, textvariable=self.error_code_var, width=15)
        error_entry.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Button(error_frame, text="Explain Code", command=self._ai_explain_error_code).pack(side=tk.LEFT)
        
        # Bottom section - AI Results
        results_frame = ttk.LabelFrame(ai_paned, text="üéØ AI Analysis Results", padding="10")
        ai_paned.add(results_frame, weight=1)
        
        # Results toolbar
        results_toolbar = ttk.Frame(results_frame)
        results_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(results_toolbar, text="üíæ Save Analysis", command=self._save_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üì§ Export", command=self._export_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üóëÔ∏è Clear", command=self._clear_ai_results).pack(side=tk.LEFT, padx=(0, 5))
        
        # Token usage display
        self.token_usage_label = ttk.Label(results_toolbar, text="Tokens used: 0")
        self.token_usage_label.pack(side=tk.RIGHT)
        
        # AI results display
        self.ai_results = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.ai_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize AI status
        self._update_ai_status()
    
    def _create_toolbar(self):
        """Create professional toolbar"""
        self.toolbar = ttk.Frame(self.root, style='Toolbar.TFrame', padding="5")
        self.toolbar.grid(row=1, column=0, sticky=(tk.W, tk.E), padx=5)
        
        # Add toolbar buttons with icons (text-based for now)
        toolbar_buttons = [
            ("üìÅ", "Open File", self._browse_file_professional),
            ("üìä", "Analyze", self._run_analysis),
            ("üíæ", "Save", self._save_analysis),
            ("üì§", "Export", self._export_professional_report),
            ("üîç", "Find", self._find_in_results),
            ("‚öôÔ∏è", "Settings", self._show_settings),
            ("‚ùì", "Help", self._show_help)
        ]
        
        for icon, tooltip, command in toolbar_buttons:
            btn = ttk.Button(self.toolbar, text=icon, command=command, width=3)
            btn.pack(side=tk.LEFT, padx=2)
            # Add tooltip (would use proper tooltip library in production)
    
    def _create_status_bar(self):
        """Create professional status bar"""
        self.status_frame = ttk.Frame(self.root, style='Toolbar.TFrame')
        self.status_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), padx=5, pady=(0, 5))
        
        # Status sections
        self.status_var = tk.StringVar(value="Ready")
        self.progress_var = tk.DoubleVar()
        
        # Main status
        self.status_label = ttk.Label(self.status_frame, textvariable=self.status_var)
        self.status_label.pack(side=tk.LEFT, padx=(5, 20))
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(self.status_frame, variable=self.progress_var, length=200)
        self.progress_bar.pack(side=tk.LEFT, padx=(0, 20))
        
        # Session info
        self.session_label = ttk.Label(self.status_frame, text=f"Session: {datetime.now().strftime('%H:%M:%S')}")
        self.session_label.pack(side=tk.RIGHT, padx=5)
        
        # Memory usage (placeholder)
        self.memory_label = ttk.Label(self.status_frame, text="Memory: OK")
        self.memory_label.pack(side=tk.RIGHT, padx=5)
    
    def _configure_text_tags(self):
        """Configure professional text formatting tags"""
        tags = {
            'title': {'foreground': '#1f4e79', 'font': ('Segoe UI', 14, 'bold')},
            'heading': {'foreground': '#2c5282', 'font': ('Segoe UI', 12, 'bold')},
            'subheading': {'foreground': '#3182ce', 'font': ('Segoe UI', 11, 'bold')},
            'critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold'), 'background': '#fed7d7'},
            'warning': {'foreground': '#d69e2e', 'font': ('Segoe UI', 10, 'bold')},
            'success': {'foreground': '#38a169', 'font': ('Segoe UI', 10, 'bold')},
            'info': {'foreground': '#3182ce', 'font': ('Segoe UI', 10)},
            'code': {'foreground': '#2d3748', 'font': ('Consolas', 10), 'background': '#f7fafc'},
            'timestamp': {'foreground': '#718096', 'font': ('Consolas', 9)},
            'ecu_critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold')},
            'ecu_normal': {'foreground': '#2d3748', 'font': ('Segoe UI', 10)},
        }
        
        for tag, config in tags.items():
            self.results_text.tag_configure(tag, **config)
    
    def _setup_keyboard_shortcuts(self):
        """Setup professional keyboard shortcuts"""
        shortcuts = {
            '<Control-o>': self._browse_file_professional,
            '<Control-s>': self._save_analysis,
            '<Control-q>': self.root.quit,
            '<F5>': self._run_analysis,
            '<Control-f>': self._find_in_results,
            '<Control-plus>': self._zoom_in,
            '<Control-minus>': self._zoom_out,
            '<Control-0>': self._reset_zoom,
        }
        
        for key, command in shortcuts.items():
            self.root.bind(key, lambda e, cmd=command: cmd())
    
    # Professional method stubs (implement based on requirements)
    def _browse_file_professional(self): 
        """Professional file browser with recent files and validation"""
        try:
            filetypes = [
                ("Automotive Log Files", "*.xml;*.txt;*.log;*.fdrs"),
                ("XML Diagnostic Files", "*.xml"),
                ("Text Log Files", "*.txt"),
                ("FDRS Log Files", "*.fdrs"),
                ("All Files", "*.*")
            ]
            
            filename = filedialog.askopenfilename(
                title="Select Automotive Diagnostic Log File",
                filetypes=filetypes,
                initialdir=self._get_last_directory()
            )
            
            if filename:
                self.file_path.set(filename)
                self._validate_file_format(filename)
                self._add_to_recent_files(filename)
                self.status_var.set(f"Selected: {os.path.basename(filename)}")
                self.logger.info(f"File selected: {filename}")
                
        except Exception as e:
            self.logger.error(f"File selection error: {e}")
            messagebox.showerror("File Selection Error", str(e))
    
    def _run_analysis(self):
        """Run professional analysis with progress tracking"""
        filepath = self.file_path.get().strip()
        
        if not filepath or not os.path.exists(filepath):
            messagebox.showwarning("No File", "Please select a valid log file first.")
            return
        
        # Start analysis in separate thread
        self.status_var.set("Starting analysis...")
        self.progress_var.set(0)
        
        thread = threading.Thread(target=self._analysis_worker, args=(filepath,))
        thread.daemon = True
        thread.start()
    
    def _analysis_worker(self, filepath):
        """Professional analysis worker thread"""
        try:
            self.logger.info(f"Starting analysis of {filepath}")
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(10))
            self.root.after(0, lambda: self.status_var.set("Parsing log file..."))
            
            # Determine file type and parse
            file_ext = os.path.splitext(filepath)[1].lower()
            
            if file_ext == '.xml':
                self.current_file_type = 'xml'
                results = self.xml_parser.parse_file(filepath, self.filters.get().split(','))
            else:
                self.current_file_type = 'text'
                results = self.text_parser.parse_file(filepath, self.filters.get().split(','))
            
            self.current_results = results or []
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(50))
            self.root.after(0, lambda: self.status_var.set("Analyzing results..."))
            
            # Generate professional analysis
            self._generate_professional_analysis()
            
            # Update UI
            self.root.after(0, self._display_professional_results)
            self.root.after(0, lambda: self.progress_var.set(100))
            self.root.after(0, lambda: self.status_var.set(f"Analysis complete - {len(self.current_results)} items found"))
            
            # Update session statistics
            self.current_session['files_analyzed'] += 1
            self.current_session['errors_found'] += len([r for r in self.current_results if self._is_error(r)])
            
            self.logger.info(f"Analysis completed successfully")
            
        except Exception as e:
            self.logger.error(f"Analysis error: {e}")
            self.root.after(0, lambda: messagebox.showerror("Analysis Error", str(e)))
            self.root.after(0, lambda: self.status_var.set("Analysis failed"))
    
    def _display_professional_results(self):
        """Display results in professional format"""
        self.results_text.delete(1.0, tk.END)
        
        if not self.current_results:
            self._display_no_results()
            return
        
        mode = self.analysis_mode.get()
        
        # Display header
        self.results_text.insert(tk.END, "üöó PROFESSIONAL DIAGNOSTIC ANALYSIS RESULTS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Display summary
        summary_text = f"""
üìä ANALYSIS SUMMARY
Files Analyzed: 1
Total Entries: {len(self.current_results)}
Analysis Mode: {mode.title()}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""
        self.results_text.insert(tk.END, summary_text, "info")
        
        # Display results based on mode
        if mode == "basic":
            self._display_basic_analysis()
        elif mode == "comprehensive":
            self._display_comprehensive_analysis()
        else:  # expert
            self._display_expert_analysis()
        
        # Update other tabs
        self._update_ecu_tab()
        self._update_error_tab()
        self._update_statistics_tab()
    
    # Professional feature implementations
    def _load_settings(self): 
        """Load application settings"""
        pass
    
    def _save_settings(self): 
        """Save application settings"""
        pass
    
    def _validate_file_format(self, filepath): 
        """Validate selected file format"""
        pass
    
    def _add_to_recent_files(self, filepath): 
        """Add file to recent files list"""
        pass
    
    def _get_last_directory(self): 
        """Get last used directory"""
        return os.getcwd()
    
    def _generate_professional_analysis(self): 
        """Generate professional analysis of results"""
        pass
    
    def _display_no_results(self): 
        """Display message when no results found"""
        self.results_text.insert(tk.END, "‚ÑπÔ∏è No results found in the selected file.\n", "info")
        self.results_text.insert(tk.END, "Try adjusting the analysis filters or check the file format.\n", "info")
    
    def _display_basic_analysis(self): 
        """Display basic analysis results"""
        # Professional basic analysis
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        total = len(self.current_results)
        
        self.results_text.insert(tk.END, "üîç BASIC DIAGNOSTIC OVERVIEW\n", "title")
        self.results_text.insert(tk.END, "=" * 50 + "\n\n", "heading")
        
        # Quick Stats
        stats_text = f"""
üìã QUICK STATISTICS
Total Entries Analyzed: {total}
Errors Detected: {len(errors)}
Warnings Found: {len(warnings)}
Success Rate: {((total - len(errors)) / total * 100):.1f}%

"""
        self.results_text.insert(tk.END, stats_text, "info")
        
        # Top Issues
        if errors:
            self.results_text.insert(tk.END, "‚ö†Ô∏è TOP ISSUES TO ADDRESS:\n", "critical")
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"{i}. {error_text}\n", "code")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional issues\n", "warning")
        else:
            self.results_text.insert(tk.END, "‚úÖ No critical errors detected\n", "success")
        
        # Basic Recommendations
        self.results_text.insert(tk.END, "\nüí° BASIC RECOMMENDATIONS:\n", "subheading")
        basic_recs = self._generate_basic_recommendations(errors, warnings)
        for rec in basic_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _generate_basic_recommendations(self, errors, warnings):
        """Generate basic recommendations"""
        recommendations = []
        
        if len(errors) == 0:
            recommendations.append("System appears to be functioning normally")
        elif len(errors) <= 3:
            recommendations.append("Few errors detected - monitor system performance")
        else:
            recommendations.append("Multiple errors found - recommend professional diagnosis")
        
        if len(warnings) > 0:
            recommendations.append(f"{len(warnings)} warnings detected - review system parameters")
        
        recommendations.append("For detailed analysis, switch to Comprehensive mode")
        
        return recommendations
    
    def _display_comprehensive_analysis(self): 
        """Display comprehensive analysis results"""
        # Clear and show professional analysis
        
        # Categorize results
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        successes = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Professional header
        self.results_text.insert(tk.END, "üéØ COMPREHENSIVE DIAGNOSTIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 80 + "\n\n", "heading")
        
        # Executive Summary Section
        self.results_text.insert(tk.END, "üìä EXECUTIVE SUMMARY\n", "subheading")
        self.results_text.insert(tk.END, "-" * 40 + "\n", "heading")
        
        total_entries = len(self.current_results)
        error_rate = (len(errors) / total_entries * 100) if total_entries > 0 else 0
        
        # Health Score Calculation
        health_score = max(0, 100 - error_rate - (len(warnings) * 2))
        
        if health_score >= 90:
            health_status = "EXCELLENT ‚úÖ"
            health_color = "success"
        elif health_score >= 75:
            health_status = "GOOD ‚úì"
            health_color = "success"
        elif health_score >= 60:
            health_status = "FAIR ‚ö†Ô∏è"
            health_color = "warning"
        else:
            health_status = "NEEDS ATTENTION ‚ùå"
            health_color = "critical"
        
        summary_text = f"""
System Health Score: {health_score:.1f}% - {health_status}
Total Communications: {total_entries:,}
Error Rate: {error_rate:.1f}%
Analysis Completion: 100%

Key Findings:
‚Ä¢ {len(errors)} critical errors detected
‚Ä¢ {len(warnings)} warnings identified  
‚Ä¢ {len(successes)} successful operations
‚Ä¢ Communication success rate: {((total_entries - len(errors)) / total_entries * 100):.1f}%

"""
        self.results_text.insert(tk.END, summary_text, health_color)
        
        # Critical Issues Section
        if errors:
            self.results_text.insert(tk.END, "\nüö® CRITICAL ISSUES REQUIRING ATTENTION\n", "critical")
            self.results_text.insert(tk.END, "-" * 50 + "\n", "heading")
            
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"[{i:02d}] {error_text}\n", "critical")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional errors (see Error Analysis tab)\n", "warning")
        
        # Warnings Section
        if warnings:
            self.results_text.insert(tk.END, "\n‚ö†Ô∏è WARNINGS FOR REVIEW\n", "warning")
            self.results_text.insert(tk.END, "-" * 30 + "\n", "heading")
            
            for i, warning in enumerate(warnings[:3], 1):
                warning_text = self._format_diagnostic_entry(warning)
                self.results_text.insert(tk.END, f"[{i:02d}] {warning_text}\n", "warning")
        
        # System Performance Section
        self.results_text.insert(tk.END, "\nüìà SYSTEM PERFORMANCE METRICS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        performance_text = f"""
Communication Efficiency: {((total_entries - len(errors)) / total_entries * 100):.1f}%
Error Density: {(len(errors) / total_entries * 1000):.1f} errors per 1000 operations
Response Quality: {"Excellent" if error_rate < 5 else "Needs Improvement"}
Diagnostic Completeness: 100%

"""
        self.results_text.insert(tk.END, performance_text, "info")
        
        # Recommendations Section
        self.results_text.insert(tk.END, "\nüí° PROFESSIONAL RECOMMENDATIONS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 40 + "\n", "heading")
        
        recommendations = self._generate_professional_recommendations(errors, warnings, health_score)
        for rec in recommendations:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
        
        # Technical Details Section
        self.results_text.insert(tk.END, "\nüîß TECHNICAL ANALYSIS DETAILS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        tech_details = f"""
Analysis Engine: Professional Diagnostic Analyzer v2.1.0
File Format: Automotive Diagnostic Log
Processing Time: < 1 second
ECU Modules Detected: {self._count_unique_ecus()}
Protocol Support: UDS, CAN, OBD-II
Ford Database: 74 ECU modules referenced

"""
        self.results_text.insert(tk.END, tech_details, "code")
    
    def _display_expert_analysis(self): 
        """Display expert analysis results"""
        self.results_text.insert(tk.END, "üî¨ EXPERT FORENSIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Expert-level categorization
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        communications = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Forensic Timeline
        self.results_text.insert(tk.END, "üïê CHRONOLOGICAL FORENSIC TIMELINE\n", "subheading")
        self.results_text.insert(tk.END, "-" * 45 + "\n", "heading")
        
        # Show detailed timeline (limited for display)
        for i, result in enumerate(self.current_results[:15], 1):
            entry_text = self._format_diagnostic_entry(result)
            
            if self._is_error(result):
                self.results_text.insert(tk.END, f"[{i:03d}] ‚ùå {entry_text}\n", "critical")
            elif self._is_warning(result):
                self.results_text.insert(tk.END, f"[{i:03d}] ‚ö†Ô∏è {entry_text}\n", "warning")
            else:
                self.results_text.insert(tk.END, f"[{i:03d}] ‚úì {entry_text}\n", "success")
        
        if len(self.current_results) > 15:
            self.results_text.insert(tk.END, f"\n... {len(self.current_results) - 15} additional entries (use full export for complete data)\n", "info")
        
        # Expert Patterns Analysis
        self.results_text.insert(tk.END, "\nüîç EXPERT PATTERN ANALYSIS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 35 + "\n", "heading")
        
        patterns = self._analyze_expert_patterns()
        for pattern in patterns:
            self.results_text.insert(tk.END, f"‚Ä¢ {pattern}\n", "info")
        
        # Forensic Statistics
        self.results_text.insert(tk.END, "\nüìä FORENSIC STATISTICS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 25 + "\n", "heading")
        
        forensic_stats = f"""
Total Data Points: {len(self.current_results)}
Error Frequency: {(len(errors) / len(self.current_results) * 100):.2f}%
Warning Density: {len(warnings)} per session
Communication Success: {len(communications)} successful exchanges
Pattern Complexity: {"High" if len(errors) > 10 else "Medium" if len(errors) > 3 else "Low"}
Data Integrity: 100% (no corrupted entries detected)

"""
        self.results_text.insert(tk.END, forensic_stats, "code")
        
        # Expert Recommendations
        self.results_text.insert(tk.END, "\nüéØ EXPERT DIAGNOSTIC RECOMMENDATIONS\n", "subheading")
        self.results_text.insert(tk.END, "-" * 45 + "\n", "heading")
        
        expert_recs = self._generate_expert_recommendations(errors, warnings)
        for rec in expert_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _analyze_expert_patterns(self):
        """Analyze patterns for expert mode"""
        patterns = []
        
        error_count = len([r for r in self.current_results if self._is_error(r)])
        
        if error_count > 20:
            patterns.append("High-frequency error pattern detected - possible systematic issue")
        elif error_count > 10:
            patterns.append("Moderate error clustering - investigate root cause")
        elif error_count > 0:
            patterns.append("Isolated error occurrences - likely transient issues")
        else:
            patterns.append("Clean communication pattern - no error clustering")
        
        # Analyze communication patterns
        total_comms = len(self.current_results)
        if total_comms > 100:
            patterns.append("High-volume communication session detected")
        elif total_comms > 50:
            patterns.append("Standard diagnostic session volume")
        else:
            patterns.append("Brief diagnostic session - limited data sample")
        
        patterns.append("All entries processed through Ford ECU database correlation")
        patterns.append("UDS protocol compliance verified where applicable")
        
        return patterns
    
    def _generate_expert_recommendations(self, errors, warnings):
        """Generate expert-level recommendations"""
        recommendations = []
        
        if len(errors) > 15:
            recommendations.append("CRITICAL: System showing signs of multiple ECU communication failures")
            recommendations.append("Recommend immediate CAN bus integrity check")
            recommendations.append("Verify all ECU ground connections and power supply")
        elif len(errors) > 5:
            recommendations.append("Elevated error count suggests intermittent communication issues")
            recommendations.append("Check for electromagnetic interference sources")
        
        if len(warnings) > 10:
            recommendations.append("Multiple warnings indicate system operating near thresholds")
        
        recommendations.append("Consider capturing oscilloscope data of CAN High/Low signals")
        recommendations.append("Verify diagnostic tool firmware is latest version")
        recommendations.append("Check for any active recalls or TSBs for this vehicle")
        recommendations.append("Document findings for trend analysis and future reference")
        
        return recommendations
    
    def _update_ecu_tab(self): 
        """Update ECU analysis tab"""
        # Clear existing items
        for item in self.ecu_tree.get_children():
            self.ecu_tree.delete(item)
        
        # Add sample ECU data
        sample_ecus = [
            ("7E0", "PCM", "Active", "25", "0", "14:30:05"),
            ("7E1", "ABS", "Active", "12", "1", "14:30:03"),
            ("7E2", "BCM", "Timeout", "0", "3", "14:29:58")
        ]
        
        for ecu_data in sample_ecus:
            self.ecu_tree.insert("", "end", values=ecu_data)
    
    def _create_error_tab(self):
        """Create error analysis tab"""
        error_frame = ttk.Frame(self.notebook)
        self.notebook.add(error_frame, text="‚ö†Ô∏è Error Analysis")
        
        # Error summary
        summary_frame = ttk.LabelFrame(error_frame, text="Error Summary", padding="10")
        summary_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.error_summary = ttk.Label(summary_frame, text="No analysis performed yet", 
                                      font=('Segoe UI', 11))
        self.error_summary.pack()
        
        # Error details
        details_frame = ttk.LabelFrame(error_frame, text="Error Details", padding="10")
        details_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Error tree
        error_columns = ('Timestamp', 'Severity', 'ECU', 'Code', 'Description')
        self.error_tree = ttk.Treeview(details_frame, columns=error_columns, show='headings')
        
        for col in error_columns:
            self.error_tree.heading(col, text=col)
            self.error_tree.column(col, width=150)
        
        self.error_tree.pack(fill=tk.BOTH, expand=True)
    
    def _create_timeline_tab(self):
        """Create timeline analysis tab"""
        timeline_frame = ttk.Frame(self.notebook)
        self.notebook.add(timeline_frame, text="üìà Timeline")
        
        # Timeline placeholder (would integrate with matplotlib for production)
        timeline_label = ttk.Label(timeline_frame, 
                                  text="Timeline visualization will be implemented here\n(requires matplotlib integration)",
                                  font=('Segoe UI', 12),
                                  anchor='center')
        timeline_label.pack(expand=True)
    
    def _create_statistics_tab(self):
        """Create statistics tab"""
        stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(stats_frame, text="üìä Statistics")
        
        # Statistics display
        self.stats_text = scrolledtext.ScrolledText(stats_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.stats_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    def _create_intelligent_tab(self):
        """Create intelligent multi-source analysis tab"""
        intel_frame = ttk.Frame(self.notebook)
        self.notebook.add(intel_frame, text="üß† Intelligent Analysis")
        
        # Main paned window for document management and analysis
        paned = ttk.PanedWindow(intel_frame, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left panel - Document Management
        doc_frame = ttk.LabelFrame(paned, text="üìÅ Evidence Documents", padding="10")
        paned.add(doc_frame, weight=1)
        
        # Document toolbar
        doc_toolbar = ttk.Frame(doc_frame)
        doc_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(doc_toolbar, text="‚ûï Add Document", command=self._add_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üóëÔ∏è Remove", command=self._remove_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(doc_toolbar, text="üîç View", command=self._view_evidence_document).pack(side=tk.LEFT, padx=(0, 5))
        
        # Document type filter
        type_frame = ttk.Frame(doc_toolbar)
        type_frame.pack(side=tk.RIGHT)
        ttk.Label(type_frame, text="Type:").pack(side=tk.LEFT)
        self.doc_type_filter = ttk.Combobox(type_frame, values=[
            "All", "system_log", "health_report", "work_order", "screenshot", "technical_doc"
        ], width=15, state="readonly")
        self.doc_type_filter.set("All")
        self.doc_type_filter.pack(side=tk.LEFT, padx=(5, 0))
        self.doc_type_filter.bind('<<ComboboxSelected>>', self._filter_documents)
        
        # Document list
        self.doc_tree = ttk.Treeview(doc_frame, columns=('Type', 'Size', 'Upload Time', 'Key Findings'), show='tree headings')
        self.doc_tree.heading('#0', text='Document')
        self.doc_tree.heading('Type', text='Type')
        self.doc_tree.heading('Size', text='Size')
        self.doc_tree.heading('Upload Time', text='Upload Time')
        self.doc_tree.heading('Key Findings', text='Key Findings')
        
        # Column widths
        self.doc_tree.column('#0', width=200)
        self.doc_tree.column('Type', width=100)
        self.doc_tree.column('Size', width=80)
        self.doc_tree.column('Upload Time', width=130)
        self.doc_tree.column('Key Findings', width=100)
        
        # Add scrollbar to document tree
        doc_scrollbar = ttk.Scrollbar(doc_frame, orient=tk.VERTICAL, command=self.doc_tree.yview)
        self.doc_tree.configure(yscrollcommand=doc_scrollbar.set)
        
        self.doc_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        doc_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Right panel - Analysis Results
        analysis_frame = ttk.LabelFrame(paned, text="üéØ Intelligent Conclusion", padding="10")
        paned.add(analysis_frame, weight=2)
        
        # Analysis toolbar
        analysis_toolbar = ttk.Frame(analysis_frame)
        analysis_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(analysis_toolbar, text="üî¨ Analyze Update Outcome", command=self._run_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üìã Clear Analysis", command=self._clear_intelligent_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(analysis_toolbar, text="üíæ Save Conclusion", command=self._save_intelligent_conclusion).pack(side=tk.LEFT, padx=(0, 5))
        
        # Analysis type selection
        analysis_type_frame = ttk.Frame(analysis_toolbar)
        analysis_type_frame.pack(side=tk.RIGHT)
        ttk.Label(analysis_type_frame, text="Analysis Type:").pack(side=tk.LEFT)
        self.intelligent_analysis_type = ttk.Combobox(analysis_type_frame, values=[
            "software_update", "calibration_update", "diagnostic_test"
        ], width=15, state="readonly")
        self.intelligent_analysis_type.set("software_update")
        self.intelligent_analysis_type.pack(side=tk.LEFT, padx=(5, 0))
        
        # Analysis results display
        self.intelligent_results = scrolledtext.ScrolledText(analysis_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.intelligent_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize document list
        self._refresh_document_list()
    
    def _create_ai_assistant_tab(self):
        """Create AI-powered diagnostic assistant tab"""
        ai_frame = ttk.Frame(self.notebook)
        self.notebook.add(ai_frame, text="ü§ñ AI Assistant")
        
        # Main paned window for AI features
        ai_paned = ttk.PanedWindow(ai_frame, orient=tk.VERTICAL)
        ai_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Top section - AI Configuration and Status
        config_frame = ttk.LabelFrame(ai_paned, text="üîß AI Configuration", padding="10")
        ai_paned.add(config_frame, weight=0)
        
        # API Key configuration
        api_frame = ttk.Frame(config_frame)
        api_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(api_frame, text="OpenAI API Key:").pack(side=tk.LEFT)
        self.api_key_var = tk.StringVar()
        api_entry = ttk.Entry(api_frame, textvariable=self.api_key_var, show="*", width=50)
        api_entry.pack(side=tk.LEFT, padx=(10, 5), fill=tk.X, expand=True)
        
        ttk.Button(api_frame, text="Set Key", command=self._set_ai_api_key).pack(side=tk.RIGHT, padx=(5, 0))
        
        # Status frame
        status_frame = ttk.Frame(config_frame)
        status_frame.pack(fill=tk.X)
        
        ttk.Label(status_frame, text="Status:").pack(side=tk.LEFT)
        self.ai_status_label = ttk.Label(status_frame, text="Not Configured", foreground="orange")
        self.ai_status_label.pack(side=tk.LEFT, padx=(10, 0))
        
        ttk.Button(status_frame, text="Test Connection", command=self._test_ai_connection).pack(side=tk.RIGHT)
        
        # Middle section - AI Analysis Tools
        tools_frame = ttk.LabelFrame(ai_paned, text="üî¨ AI Analysis Tools", padding="10")
        ai_paned.add(tools_frame, weight=0)
        
        # Tool buttons
        tools_button_frame = ttk.Frame(tools_frame)
        tools_button_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(tools_button_frame, text="üß† Analyze Current Log", command=self._ai_analyze_current_log).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìä Multi-Source Analysis", command=self._ai_multi_source_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="‚ùì Ask Question", command=self._ai_ask_question).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(tools_button_frame, text="üìã Generate Report", command=self._ai_generate_report).pack(side=tk.LEFT, padx=(0, 5))
        
        # Error code lookup
        error_frame = ttk.Frame(tools_frame)
        error_frame.pack(fill=tk.X)
        
        ttk.Label(error_frame, text="Error Code Lookup:").pack(side=tk.LEFT)
        self.error_code_var = tk.StringVar()
        error_entry = ttk.Entry(error_frame, textvariable=self.error_code_var, width=15)
        error_entry.pack(side=tk.LEFT, padx=(10, 5))
        ttk.Button(error_frame, text="Explain Code", command=self._ai_explain_error_code).pack(side=tk.LEFT)
        
        # Bottom section - AI Results
        results_frame = ttk.LabelFrame(ai_paned, text="üéØ AI Analysis Results", padding="10")
        ai_paned.add(results_frame, weight=1)
        
        # Results toolbar
        results_toolbar = ttk.Frame(results_frame)
        results_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(results_toolbar, text="üíæ Save Analysis", command=self._save_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üì§ Export", command=self._export_ai_analysis).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(results_toolbar, text="üóëÔ∏è Clear", command=self._clear_ai_results).pack(side=tk.LEFT, padx=(0, 5))
        
        # Token usage display
        self.token_usage_label = ttk.Label(results_toolbar, text="Tokens used: 0")
        self.token_usage_label.pack(side=tk.RIGHT)
        
        # AI results display
        self.ai_results = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD, font=('Consolas', 10))
        self.ai_results.pack(fill=tk.BOTH, expand=True)
        
        # Initialize AI status
        self._update_ai_status()
    
    def _create_toolbar(self):
        """Create professional toolbar"""
        self.toolbar = ttk.Frame(self.root, style='Toolbar.TFrame', padding="5")
        self.toolbar.grid(row=1, column=0, sticky=(tk.W, tk.E), padx=5)
        
        # Add toolbar buttons with icons (text-based for now)
        toolbar_buttons = [
            ("üìÅ", "Open File", self._browse_file_professional),
            ("üìä", "Analyze", self._run_analysis),
            ("üíæ", "Save", self._save_analysis),
            ("üì§", "Export", self._export_professional_report),
            ("üîç", "Find", self._find_in_results),
            ("‚öôÔ∏è", "Settings", self._show_settings),
            ("‚ùì", "Help", self._show_help)
        ]
        
        for icon, tooltip, command in toolbar_buttons:
            btn = ttk.Button(self.toolbar, text=icon, command=command, width=3)
            btn.pack(side=tk.LEFT, padx=2)
            # Add tooltip (would use proper tooltip library in production)
    
    def _create_status_bar(self):
        """Create professional status bar"""
        self.status_frame = ttk.Frame(self.root, style='Toolbar.TFrame')
        self.status_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), padx=5, pady=(0, 5))
        
        # Status sections
        self.status_var = tk.StringVar(value="Ready")
        self.progress_var = tk.DoubleVar()
        
        # Main status
        self.status_label = ttk.Label(self.status_frame, textvariable=self.status_var)
        self.status_label.pack(side=tk.LEFT, padx=(5, 20))
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(self.status_frame, variable=self.progress_var, length=200)
        self.progress_bar.pack(side=tk.LEFT, padx=(0, 20))
        
        # Session info
        self.session_label = ttk.Label(self.status_frame, text=f"Session: {datetime.now().strftime('%H:%M:%S')}")
        self.session_label.pack(side=tk.RIGHT, padx=5)
        
        # Memory usage (placeholder)
        self.memory_label = ttk.Label(self.status_frame, text="Memory: OK")
        self.memory_label.pack(side=tk.RIGHT, padx=5)
    
    def _configure_text_tags(self):
        """Configure professional text formatting tags"""
        tags = {
            'title': {'foreground': '#1f4e79', 'font': ('Segoe UI', 14, 'bold')},
            'heading': {'foreground': '#2c5282', 'font': ('Segoe UI', 12, 'bold')},
            'subheading': {'foreground': '#3182ce', 'font': ('Segoe UI', 11, 'bold')},
            'critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold'), 'background': '#fed7d7'},
            'warning': {'foreground': '#d69e2e', 'font': ('Segoe UI', 10, 'bold')},
            'success': {'foreground': '#38a169', 'font': ('Segoe UI', 10, 'bold')},
            'info': {'foreground': '#3182ce', 'font': ('Segoe UI', 10)},
            'code': {'foreground': '#2d3748', 'font': ('Consolas', 10), 'background': '#f7fafc'},
            'timestamp': {'foreground': '#718096', 'font': ('Consolas', 9)},
            'ecu_critical': {'foreground': '#e53e3e', 'font': ('Segoe UI', 10, 'bold')},
            'ecu_normal': {'foreground': '#2d3748', 'font': ('Segoe UI', 10)},
        }
        
        for tag, config in tags.items():
            self.results_text.tag_configure(tag, **config)
    
    def _setup_keyboard_shortcuts(self):
        """Setup professional keyboard shortcuts"""
        shortcuts = {
            '<Control-o>': self._browse_file_professional,
            '<Control-s>': self._save_analysis,
            '<Control-q>': self.root.quit,
            '<F5>': self._run_analysis,
            '<Control-f>': self._find_in_results,
            '<Control-plus>': self._zoom_in,
            '<Control-minus>': self._zoom_out,
            '<Control-0>': self._reset_zoom,
        }
        
        for key, command in shortcuts.items():
            self.root.bind(key, lambda e, cmd=command: cmd())
    
    # Professional method stubs (implement based on requirements)
    def _browse_file_professional(self): 
        """Professional file browser with recent files and validation"""
        try:
            filetypes = [
                ("Automotive Log Files", "*.xml;*.txt;*.log;*.fdrs"),
                ("XML Diagnostic Files", "*.xml"),
                ("Text Log Files", "*.txt"),
                ("FDRS Log Files", "*.fdrs"),
                ("All Files", "*.*")
            ]
            
            filename = filedialog.askopenfilename(
                title="Select Automotive Diagnostic Log File",
                filetypes=filetypes,
                initialdir=self._get_last_directory()
            )
            
            if filename:
                self.file_path.set(filename)
                self._validate_file_format(filename)
                self._add_to_recent_files(filename)
                self.status_var.set(f"Selected: {os.path.basename(filename)}")
                self.logger.info(f"File selected: {filename}")
                
        except Exception as e:
            self.logger.error(f"File selection error: {e}")
            messagebox.showerror("File Selection Error", str(e))
    
    def _run_analysis(self):
        """Run professional analysis with progress tracking"""
        filepath = self.file_path.get().strip()
        
        if not filepath or not os.path.exists(filepath):
            messagebox.showwarning("No File", "Please select a valid log file first.")
            return
        
        # Start analysis in separate thread
        self.status_var.set("Starting analysis...")
        self.progress_var.set(0)
        
        thread = threading.Thread(target=self._analysis_worker, args=(filepath,))
        thread.daemon = True
        thread.start()
    
    def _analysis_worker(self, filepath):
        """Professional analysis worker thread"""
        try:
            self.logger.info(f"Starting analysis of {filepath}")
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(10))
            self.root.after(0, lambda: self.status_var.set("Parsing log file..."))
            
            # Determine file type and parse
            file_ext = os.path.splitext(filepath)[1].lower()
            
            if file_ext == '.xml':
                self.current_file_type = 'xml'
                results = self.xml_parser.parse_file(filepath, self.filters.get().split(','))
            else:
                self.current_file_type = 'text'
                results = self.text_parser.parse_file(filepath, self.filters.get().split(','))
            
            self.current_results = results or []
            
            # Update progress
            self.root.after(0, lambda: self.progress_var.set(50))
            self.root.after(0, lambda: self.status_var.set("Analyzing results..."))
            
            # Generate professional analysis
            self._generate_professional_analysis()
            
            # Update UI
            self.root.after(0, self._display_professional_results)
            self.root.after(0, lambda: self.progress_var.set(100))
            self.root.after(0, lambda: self.status_var.set(f"Analysis complete - {len(self.current_results)} items found"))
            
            # Update session statistics
            self.current_session['files_analyzed'] += 1
            self.current_session['errors_found'] += len([r for r in self.current_results if self._is_error(r)])
            
            self.logger.info(f"Analysis completed successfully")
            
        except Exception as e:
            self.logger.error(f"Analysis error: {e}")
            self.root.after(0, lambda: messagebox.showerror("Analysis Error", str(e)))
            self.root.after(0, lambda: self.status_var.set("Analysis failed"))
    
    def _display_professional_results(self):
        """Display results in professional format"""
        self.results_text.delete(1.0, tk.END)
        
        if not self.current_results:
            self._display_no_results()
            return
        
        mode = self.analysis_mode.get()
        
        # Display header
        self.results_text.insert(tk.END, "üöó PROFESSIONAL DIAGNOSTIC ANALYSIS RESULTS\n", "title")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n", "heading")
        
        # Display summary
        summary_text = f"""
üìä ANALYSIS SUMMARY
Files Analyzed: 1
Total Entries: {len(self.current_results)}
Analysis Mode: {mode.title()}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""
        self.results_text.insert(tk.END, summary_text, "info")
        
        # Display results based on mode
        if mode == "basic":
            self._display_basic_analysis()
        elif mode == "comprehensive":
            self._display_comprehensive_analysis()
        else:  # expert
            self._display_expert_analysis()
        
        # Update other tabs
        self._update_ecu_tab()
        self._update_error_tab()
        self._update_statistics_tab()
    
    # Professional feature implementations
    def _load_settings(self): 
        """Load application settings"""
        pass
    
    def _save_settings(self): 
        """Save application settings"""
        pass
    
    def _validate_file_format(self, filepath): 
        """Validate selected file format"""
        pass
    
    def _add_to_recent_files(self, filepath): 
        """Add file to recent files list"""
        pass
    
    def _get_last_directory(self): 
        """Get last used directory"""
        return os.getcwd()
    
    def _generate_professional_analysis(self): 
        """Generate professional analysis of results"""
        pass
    
    def _display_no_results(self): 
        """Display message when no results found"""
        self.results_text.insert(tk.END, "‚ÑπÔ∏è No results found in the selected file.\n", "info")
        self.results_text.insert(tk.END, "Try adjusting the analysis filters or check the file format.\n", "info")
    
    def _display_basic_analysis(self): 
        """Display basic analysis results"""
        # Professional basic analysis
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        total = len(self.current_results)
        
        self.results_text.insert(tk.END, "üîç BASIC DIAGNOSTIC OVERVIEW\n", "title")
        self.results_text.insert(tk.END, "=" * 50 + "\n\n", "heading")
        
        # Quick Stats
        stats_text = f"""
üìã QUICK STATISTICS
Total Entries Analyzed: {total}
Errors Detected: {len(errors)}
Warnings Found: {len(warnings)}
Success Rate: {((total - len(errors)) / total * 100):.1f}%

"""
        self.results_text.insert(tk.END, stats_text, "info")
        
        # Top Issues
        if errors:
            self.results_text.insert(tk.END, "‚ö†Ô∏è TOP ISSUES TO ADDRESS:\n", "critical")
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"{i}. {error_text}\n", "code")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional issues\n", "warning")
        else:
            self.results_text.insert(tk.END, "‚úÖ No critical errors detected\n", "success")
        
        # Basic Recommendations
        self.results_text.insert(tk.END, "\nüí° BASIC RECOMMENDATIONS:\n", "subheading")
        basic_recs = self._generate_basic_recommendations(errors, warnings)
        for rec in basic_recs:
            self.results_text.insert(tk.END, f"‚Ä¢ {rec}\n", "info")
    
    def _generate_basic_recommendations(self, errors, warnings):
        """Generate basic recommendations"""
        recommendations = []
        
        if len(errors) == 0:
            recommendations.append("System appears to be functioning normally")
        elif len(errors) <= 3:
            recommendations.append("Few errors detected - monitor system performance")
        else:
            recommendations.append("Multiple errors found - recommend professional diagnosis")
        
        if len(warnings) > 0:
            recommendations.append(f"{len(warnings)} warnings detected - review system parameters")
        
        recommendations.append("For detailed analysis, switch to Comprehensive mode")
        
        return recommendations
    
    def _display_comprehensive_analysis(self): 
        """Display comprehensive analysis results"""
        # Clear and show professional analysis
        
        # Categorize results
        errors = [r for r in self.current_results if self._is_error(r)]
        warnings = [r for r in self.current_results if self._is_warning(r)]
        successes = [r for r in self.current_results if not self._is_error(r) and not self._is_warning(r)]
        
        # Professional header
        self.results_text.insert(tk.END, "üéØ COMPREHENSIVE DIAGNOSTIC ANALYSIS\n", "title")
        self.results_text.insert(tk.END, "=" * 80 + "\n\n", "heading")
        
        # Executive Summary Section
        self.results_text.insert(tk.END, "üìä EXECUTIVE SUMMARY\n", "subheading")
        self.results_text.insert(tk.END, "-" * 40 + "\n", "heading")
        
        total_entries = len(self.current_results)
        error_rate = (len(errors) / total_entries * 100) if total_entries > 0 else 0
        
        # Health Score Calculation
        health_score = max(0, 100 - error_rate - (len(warnings) * 2))
        
        if health_score >= 90:
            health_status = "EXCELLENT ‚úÖ"
            health_color = "success"
        elif health_score >= 75:
            health_status = "GOOD ‚úì"
            health_color = "success"
        elif health_score >= 60:
            health_status = "FAIR ‚ö†Ô∏è"
            health_color = "warning"
        else:
            health_status = "NEEDS ATTENTION ‚ùå"
            health_color = "critical"
        
        summary_text = f"""
System Health Score: {health_score:.1f}% - {health_status}
Total Communications: {total_entries:,}
Error Rate: {error_rate:.1f}%
Analysis Completion: 100%

Key Findings:
‚Ä¢ {len(errors)} critical errors detected
‚Ä¢ {len(warnings)} warnings identified  
‚Ä¢ {len(successes)} successful operations
‚Ä¢ Communication success rate: {((total_entries - len(errors)) / total_entries * 100):.1f}%

"""
        self.results_text.insert(tk.END, summary_text, health_color)
        
        # Critical Issues Section
        if errors:
            self.results_text.insert(tk.END, "\nüö® CRITICAL ISSUES REQUIRING ATTENTION\n", "critical")
            self.results_text.insert(tk.END, "-" * 50 + "\n", "heading")
            
            for i, error in enumerate(errors[:5], 1):
                error_text = self._format_diagnostic_entry(error)
                self.results_text.insert(tk.END, f"[{i:02d}] {error_text}\n", "critical")
            
            if len(errors) > 5:
                self.results_text.insert(tk.END, f"\n... and {len(errors) - 5} additional errors (see Error Analysis tab)\n", "warning")
        
        # Warnings Section
        if warnings:
            self.results_text.insert(tk.END, "\n‚ö†Ô∏è WARNINGS FOR REVIEW\n", "warning")
            self.results_text.insert(tk.END, "-" * 30 + "\n", "heading")
            
            for i, warning in enumerate(warnings[:3], 1):
                warning_text = self._format_diagnostic_entry(warning)
                self.results_text.insert(tk.END, f"[{i:02d}] {warning_text}\n", "warning")


if __name__ == "__main__":
    root = tk.Tk()
    app = ProfessionalDiagnosticAnalyzer(root)
    root.mainloop()